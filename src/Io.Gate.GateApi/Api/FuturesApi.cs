/*
 * Gate API v4
 *
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user's behalf.
 *
 * Contact: support@mail.gate.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using System.Threading.Tasks;
using Io.Gate.GateApi.Client;
using Io.Gate.GateApi.Model;

namespace Io.Gate.GateApi.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFuturesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// List all futures contracts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>List&lt;Contract&gt;</returns>
        List<Contract> ListFuturesContracts (string settle);

        /// <summary>
        /// List all futures contracts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>ApiResponse of List&lt;Contract&gt;</returns>
        ApiResponse<List<Contract>> ListFuturesContractsWithHttpInfo (string settle);
        /// <summary>
        /// Get a single contract
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Contract</returns>
        Contract GetFuturesContract (string settle, string contract);

        /// <summary>
        /// Get a single contract
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of Contract</returns>
        ApiResponse<Contract> GetFuturesContractWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Futures order book
        /// </summary>
        /// <remarks>
        /// Bids will be sorted by price from high to low, while asks sorted reversely
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to 0)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>FuturesOrderBook</returns>
        FuturesOrderBook ListFuturesOrderBook (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));

        /// <summary>
        /// Futures order book
        /// </summary>
        /// <remarks>
        /// Bids will be sorted by price from high to low, while asks sorted reversely
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to 0)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>ApiResponse of FuturesOrderBook</returns>
        ApiResponse<FuturesOrderBook> ListFuturesOrderBookWithHttpInfo (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));
        /// <summary>
        /// Futures trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>List&lt;FuturesTrade&gt;</returns>
        List<FuturesTrade> ListFuturesTrades (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// Futures trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesTrade&gt;</returns>
        ApiResponse<List<FuturesTrade>> ListFuturesTradesWithHttpInfo (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// Get futures candlesticks
        /// </summary>
        /// <remarks>
        /// Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0 (optional, default to 5m)</param>
        /// <returns>List&lt;FuturesCandlestick&gt;</returns>
        List<FuturesCandlestick> ListFuturesCandlesticks (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));

        /// <summary>
        /// Get futures candlesticks
        /// </summary>
        /// <remarks>
        /// Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0 (optional, default to 5m)</param>
        /// <returns>ApiResponse of List&lt;FuturesCandlestick&gt;</returns>
        ApiResponse<List<FuturesCandlestick>> ListFuturesCandlesticksWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));
        /// <summary>
        /// Premium Index K-Line
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to 5m)</param>
        /// <returns>List&lt;FuturesPremiumIndex&gt;</returns>
        List<FuturesPremiumIndex> ListFuturesPremiumIndex (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));

        /// <summary>
        /// Premium Index K-Line
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to 5m)</param>
        /// <returns>ApiResponse of List&lt;FuturesPremiumIndex&gt;</returns>
        ApiResponse<List<FuturesPremiumIndex>> ListFuturesPremiumIndexWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));
        /// <summary>
        /// List futures tickers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>List&lt;FuturesTicker&gt;</returns>
        List<FuturesTicker> ListFuturesTickers (string settle, string contract = default(string));

        /// <summary>
        /// List futures tickers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesTicker&gt;</returns>
        ApiResponse<List<FuturesTicker>> ListFuturesTickersWithHttpInfo (string settle, string contract = default(string));
        /// <summary>
        /// Funding rate history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;FundingRateRecord&gt;</returns>
        List<FundingRateRecord> ListFuturesFundingRateHistory (string settle, string contract, int? limit = default(int?));

        /// <summary>
        /// Funding rate history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;FundingRateRecord&gt;</returns>
        ApiResponse<List<FundingRateRecord>> ListFuturesFundingRateHistoryWithHttpInfo (string settle, string contract, int? limit = default(int?));
        /// <summary>
        /// Futures insurance balance history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;InsuranceRecord&gt;</returns>
        List<InsuranceRecord> ListFuturesInsuranceLedger (string settle, int? limit = default(int?));

        /// <summary>
        /// Futures insurance balance history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;InsuranceRecord&gt;</returns>
        ApiResponse<List<InsuranceRecord>> ListFuturesInsuranceLedgerWithHttpInfo (string settle, int? limit = default(int?));
        /// <summary>
        /// Futures stats
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to 5m)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>List&lt;ContractStat&gt;</returns>
        List<ContractStat> ListContractStats (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?));

        /// <summary>
        /// Futures stats
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to 5m)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>ApiResponse of List&lt;ContractStat&gt;</returns>
        ApiResponse<List<ContractStat>> ListContractStatsWithHttpInfo (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?));
        /// <summary>
        /// Get index constituents
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>FuturesIndexConstituents</returns>
        FuturesIndexConstituents GetIndexConstituents (string settle, string index);

        /// <summary>
        /// Get index constituents
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>ApiResponse of FuturesIndexConstituents</returns>
        ApiResponse<FuturesIndexConstituents> GetIndexConstituentsWithHttpInfo (string settle, string index);
        /// <summary>
        /// Retrieve liquidation history
        /// </summary>
        /// <remarks>
        /// Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;FuturesLiquidate&gt;</returns>
        List<FuturesLiquidate> ListLiquidatedOrders (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?));

        /// <summary>
        /// Retrieve liquidation history
        /// </summary>
        /// <remarks>
        /// Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;FuturesLiquidate&gt;</returns>
        ApiResponse<List<FuturesLiquidate>> ListLiquidatedOrdersWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?));
        /// <summary>
        /// Query futures account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>FuturesAccount</returns>
        FuturesAccount ListFuturesAccounts (string settle);

        /// <summary>
        /// Query futures account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>ApiResponse of FuturesAccount</returns>
        ApiResponse<FuturesAccount> ListFuturesAccountsWithHttpInfo (string settle);
        /// <summary>
        /// Query account book
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate (optional)</param>
        /// <returns>List&lt;FuturesAccountBook&gt;</returns>
        List<FuturesAccountBook> ListFuturesAccountBook (string settle, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string));

        /// <summary>
        /// Query account book
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesAccountBook&gt;</returns>
        ApiResponse<List<FuturesAccountBook>> ListFuturesAccountBookWithHttpInfo (string settle, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string));
        /// <summary>
        /// List all positions of a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> ListPositions (string settle);

        /// <summary>
        /// List all positions of a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> ListPositionsWithHttpInfo (string settle);
        /// <summary>
        /// Get single position
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Position</returns>
        Position GetPosition (string settle, string contract);

        /// <summary>
        /// Get single position
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of Position</returns>
        ApiResponse<Position> GetPositionWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Update position margin
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Position</returns>
        Position UpdatePositionMargin (string settle, string contract, string change);

        /// <summary>
        /// Update position margin
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>ApiResponse of Position</returns>
        ApiResponse<Position> UpdatePositionMarginWithHttpInfo (string settle, string contract, string change);
        /// <summary>
        /// Update position leverage
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Position</returns>
        Position UpdatePositionLeverage (string settle, string contract, string leverage, string crossLeverageLimit = default(string));

        /// <summary>
        /// Update position leverage
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>ApiResponse of Position</returns>
        ApiResponse<Position> UpdatePositionLeverageWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string));
        /// <summary>
        /// Update position risk limit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Position</returns>
        Position UpdatePositionRiskLimit (string settle, string contract, string riskLimit);

        /// <summary>
        /// Update position risk limit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>ApiResponse of Position</returns>
        ApiResponse<Position> UpdatePositionRiskLimitWithHttpInfo (string settle, string contract, string riskLimit);
        /// <summary>
        /// Enable or disable dual mode
        /// </summary>
        /// <remarks>
        /// Before setting dual mode, make sure all positions are closed and no orders are open
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>FuturesAccount</returns>
        FuturesAccount SetDualMode (string settle, bool dualMode);

        /// <summary>
        /// Enable or disable dual mode
        /// </summary>
        /// <remarks>
        /// Before setting dual mode, make sure all positions are closed and no orders are open
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>ApiResponse of FuturesAccount</returns>
        ApiResponse<FuturesAccount> SetDualModeWithHttpInfo (string settle, bool dualMode);
        /// <summary>
        /// Retrieve position detail in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> GetDualModePosition (string settle, string contract);

        /// <summary>
        /// Retrieve position detail in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> GetDualModePositionWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Update position margin in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> UpdateDualModePositionMargin (string settle, string contract, string change, string dualSide);

        /// <summary>
        /// Update position margin in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> UpdateDualModePositionMarginWithHttpInfo (string settle, string contract, string change, string dualSide);
        /// <summary>
        /// Update position leverage in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> UpdateDualModePositionLeverage (string settle, string contract, string leverage, string crossLeverageLimit = default(string));

        /// <summary>
        /// Update position leverage in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> UpdateDualModePositionLeverageWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string));
        /// <summary>
        /// Update position risk limit in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> UpdateDualModePositionRiskLimit (string settle, string contract, string riskLimit);

        /// <summary>
        /// Update position risk limit in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> UpdateDualModePositionRiskLimitWithHttpInfo (string settle, string contract, string riskLimit);
        /// <summary>
        /// List futures orders
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        List<FuturesOrder> ListFuturesOrders (string settle, string contract, string status, int? limit = default(int?), int? offset = default(int?), string lastId = default(string));

        /// <summary>
        /// List futures orders
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        ApiResponse<List<FuturesOrder>> ListFuturesOrdersWithHttpInfo (string settle, string contract, string status, int? limit = default(int?), int? offset = default(int?), string lastId = default(string));
        /// <summary>
        /// Create a futures order
        /// </summary>
        /// <remarks>
        /// - Creating futures orders requires &#x60;size&#x60;, which is number of contracts instead of currency amount. You can use &#x60;quanto_multiplier&#x60; in contract detail response to know how much currency 1 size contract represents - Zero-filled order cannot be retrieved 10 minutes after order cancellation. You will get a 404 not found for such orders - Set &#x60;reduce_only&#x60; to &#x60;true&#x60; can keep the position from changing side when reducing position size - In single position mode, to close a position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual position mode, to close one side position, you need to set &#x60;auto_size&#x60; side, &#x60;reduce_only&#x60; to true and &#x60;size&#x60; to 0
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>FuturesOrder</returns>
        FuturesOrder CreateFuturesOrder (string settle, FuturesOrder futuresOrder);

        /// <summary>
        /// Create a futures order
        /// </summary>
        /// <remarks>
        /// - Creating futures orders requires &#x60;size&#x60;, which is number of contracts instead of currency amount. You can use &#x60;quanto_multiplier&#x60; in contract detail response to know how much currency 1 size contract represents - Zero-filled order cannot be retrieved 10 minutes after order cancellation. You will get a 404 not found for such orders - Set &#x60;reduce_only&#x60; to &#x60;true&#x60; can keep the position from changing side when reducing position size - In single position mode, to close a position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual position mode, to close one side position, you need to set &#x60;auto_size&#x60; side, &#x60;reduce_only&#x60; to true and &#x60;size&#x60; to 0
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        ApiResponse<FuturesOrder> CreateFuturesOrderWithHttpInfo (string settle, FuturesOrder futuresOrder);
        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="side">All bids or asks. Both included if not specified (optional)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        List<FuturesOrder> CancelFuturesOrders (string settle, string contract, string side = default(string));

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="side">All bids or asks. Both included if not specified (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        ApiResponse<List<FuturesOrder>> CancelFuturesOrdersWithHttpInfo (string settle, string contract, string side = default(string));
        /// <summary>
        /// Create a batch of futures orders
        /// </summary>
        /// <remarks>
        /// - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>List&lt;BatchFuturesOrder&gt;</returns>
        List<BatchFuturesOrder> CreateBatchFuturesOrder (string settle, List<FuturesOrder> futuresOrder);

        /// <summary>
        /// Create a batch of futures orders
        /// </summary>
        /// <remarks>
        /// - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>ApiResponse of List&lt;BatchFuturesOrder&gt;</returns>
        ApiResponse<List<BatchFuturesOrder>> CreateBatchFuturesOrderWithHttpInfo (string settle, List<FuturesOrder> futuresOrder);
        /// <summary>
        /// Get a single order
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>FuturesOrder</returns>
        FuturesOrder GetFuturesOrder (string settle, string orderId);

        /// <summary>
        /// Get a single order
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        ApiResponse<FuturesOrder> GetFuturesOrderWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// Amend an order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <returns>FuturesOrder</returns>
        FuturesOrder AmendFuturesOrder (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment);

        /// <summary>
        /// Amend an order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        ApiResponse<FuturesOrder> AmendFuturesOrderWithHttpInfo (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment);
        /// <summary>
        /// Cancel a single order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>FuturesOrder</returns>
        FuturesOrder CancelFuturesOrder (string settle, string orderId);

        /// <summary>
        /// Cancel a single order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        ApiResponse<FuturesOrder> CancelFuturesOrderWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// List personal trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>List&lt;MyFuturesTrade&gt;</returns>
        List<MyFuturesTrade> GetMyTrades (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));

        /// <summary>
        /// List personal trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>ApiResponse of List&lt;MyFuturesTrade&gt;</returns>
        ApiResponse<List<MyFuturesTrade>> GetMyTradesWithHttpInfo (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));
        /// <summary>
        /// List personal trading history by time range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;MyFuturesTrade&gt;</returns>
        List<MyFuturesTrade> GetMyTradesWithTimeRange (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List personal trading history by time range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;MyFuturesTrade&gt;</returns>
        ApiResponse<List<MyFuturesTrade>> GetMyTradesWithTimeRangeWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// List position close history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>List&lt;PositionClose&gt;</returns>
        List<PositionClose> ListPositionClose (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// List position close history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>ApiResponse of List&lt;PositionClose&gt;</returns>
        ApiResponse<List<PositionClose>> ListPositionCloseWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// List liquidation history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>List&lt;FuturesLiquidate&gt;</returns>
        List<FuturesLiquidate> ListLiquidates (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));

        /// <summary>
        /// List liquidation history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesLiquidate&gt;</returns>
        ApiResponse<List<FuturesLiquidate>> ListLiquidatesWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));
        /// <summary>
        /// List Auto-Deleveraging History
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>List&lt;FuturesAutoDeleverage&gt;</returns>
        List<FuturesAutoDeleverage> ListAutoDeleverages (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));

        /// <summary>
        /// List Auto-Deleveraging History
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesAutoDeleverage&gt;</returns>
        ApiResponse<List<FuturesAutoDeleverage>> ListAutoDeleveragesWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));
        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>TriggerTime</returns>
        TriggerTime CountdownCancelAllFutures (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask);

        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>ApiResponse of TriggerTime</returns>
        ApiResponse<TriggerTime> CountdownCancelAllFuturesWithHttpInfo (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask);
        /// <summary>
        /// List all auto orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        List<FuturesPriceTriggeredOrder> ListPriceTriggeredOrders (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List all auto orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        ApiResponse<List<FuturesPriceTriggeredOrder>> ListPriceTriggeredOrdersWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Create a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>TriggerOrderResponse</returns>
        TriggerOrderResponse CreatePriceTriggeredOrder (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder);

        /// <summary>
        /// Create a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>ApiResponse of TriggerOrderResponse</returns>
        ApiResponse<TriggerOrderResponse> CreatePriceTriggeredOrderWithHttpInfo (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder);
        /// <summary>
        /// Cancel all open orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        List<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderList (string settle, string contract);

        /// <summary>
        /// Cancel all open orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        ApiResponse<List<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderListWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Get a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>FuturesPriceTriggeredOrder</returns>
        FuturesPriceTriggeredOrder GetPriceTriggeredOrder (string settle, string orderId);

        /// <summary>
        /// Get a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>ApiResponse of FuturesPriceTriggeredOrder</returns>
        ApiResponse<FuturesPriceTriggeredOrder> GetPriceTriggeredOrderWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// cancel a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>FuturesPriceTriggeredOrder</returns>
        FuturesPriceTriggeredOrder CancelPriceTriggeredOrder (string settle, string orderId);

        /// <summary>
        /// cancel a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>ApiResponse of FuturesPriceTriggeredOrder</returns>
        ApiResponse<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderWithHttpInfo (string settle, string orderId);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFuturesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// List all futures contracts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of List&lt;Contract&gt;</returns>
        Task<List<Contract>> ListFuturesContractsAsync (string settle);

        /// <summary>
        /// List all futures contracts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of ApiResponse (List&lt;Contract&gt;)</returns>
        Task<ApiResponse<List<Contract>>> ListFuturesContractsAsyncWithHttpInfo (string settle);
        /// <summary>
        /// Get a single contract
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of Contract</returns>
        Task<Contract> GetFuturesContractAsync (string settle, string contract);

        /// <summary>
        /// Get a single contract
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (Contract)</returns>
        Task<ApiResponse<Contract>> GetFuturesContractAsyncWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Futures order book
        /// </summary>
        /// <remarks>
        /// Bids will be sorted by price from high to low, while asks sorted reversely
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to 0)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>Task of FuturesOrderBook</returns>
        Task<FuturesOrderBook> ListFuturesOrderBookAsync (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));

        /// <summary>
        /// Futures order book
        /// </summary>
        /// <remarks>
        /// Bids will be sorted by price from high to low, while asks sorted reversely
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to 0)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>Task of ApiResponse (FuturesOrderBook)</returns>
        Task<ApiResponse<FuturesOrderBook>> ListFuturesOrderBookAsyncWithHttpInfo (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));
        /// <summary>
        /// Futures trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>Task of List&lt;FuturesTrade&gt;</returns>
        Task<List<FuturesTrade>> ListFuturesTradesAsync (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// Futures trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesTrade&gt;)</returns>
        Task<ApiResponse<List<FuturesTrade>>> ListFuturesTradesAsyncWithHttpInfo (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// Get futures candlesticks
        /// </summary>
        /// <remarks>
        /// Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0 (optional, default to 5m)</param>
        /// <returns>Task of List&lt;FuturesCandlestick&gt;</returns>
        Task<List<FuturesCandlestick>> ListFuturesCandlesticksAsync (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));

        /// <summary>
        /// Get futures candlesticks
        /// </summary>
        /// <remarks>
        /// Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0 (optional, default to 5m)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesCandlestick&gt;)</returns>
        Task<ApiResponse<List<FuturesCandlestick>>> ListFuturesCandlesticksAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));
        /// <summary>
        /// Premium Index K-Line
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to 5m)</param>
        /// <returns>Task of List&lt;FuturesPremiumIndex&gt;</returns>
        Task<List<FuturesPremiumIndex>> ListFuturesPremiumIndexAsync (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));

        /// <summary>
        /// Premium Index K-Line
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to 5m)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPremiumIndex&gt;)</returns>
        Task<ApiResponse<List<FuturesPremiumIndex>>> ListFuturesPremiumIndexAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));
        /// <summary>
        /// List futures tickers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of List&lt;FuturesTicker&gt;</returns>
        Task<List<FuturesTicker>> ListFuturesTickersAsync (string settle, string contract = default(string));

        /// <summary>
        /// List futures tickers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesTicker&gt;)</returns>
        Task<ApiResponse<List<FuturesTicker>>> ListFuturesTickersAsyncWithHttpInfo (string settle, string contract = default(string));
        /// <summary>
        /// Funding rate history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;FundingRateRecord&gt;</returns>
        Task<List<FundingRateRecord>> ListFuturesFundingRateHistoryAsync (string settle, string contract, int? limit = default(int?));

        /// <summary>
        /// Funding rate history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;FundingRateRecord&gt;)</returns>
        Task<ApiResponse<List<FundingRateRecord>>> ListFuturesFundingRateHistoryAsyncWithHttpInfo (string settle, string contract, int? limit = default(int?));
        /// <summary>
        /// Futures insurance balance history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;InsuranceRecord&gt;</returns>
        Task<List<InsuranceRecord>> ListFuturesInsuranceLedgerAsync (string settle, int? limit = default(int?));

        /// <summary>
        /// Futures insurance balance history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;InsuranceRecord&gt;)</returns>
        Task<ApiResponse<List<InsuranceRecord>>> ListFuturesInsuranceLedgerAsyncWithHttpInfo (string settle, int? limit = default(int?));
        /// <summary>
        /// Futures stats
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to 5m)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>Task of List&lt;ContractStat&gt;</returns>
        Task<List<ContractStat>> ListContractStatsAsync (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?));

        /// <summary>
        /// Futures stats
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to 5m)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>Task of ApiResponse (List&lt;ContractStat&gt;)</returns>
        Task<ApiResponse<List<ContractStat>>> ListContractStatsAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?));
        /// <summary>
        /// Get index constituents
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>Task of FuturesIndexConstituents</returns>
        Task<FuturesIndexConstituents> GetIndexConstituentsAsync (string settle, string index);

        /// <summary>
        /// Get index constituents
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>Task of ApiResponse (FuturesIndexConstituents)</returns>
        Task<ApiResponse<FuturesIndexConstituents>> GetIndexConstituentsAsyncWithHttpInfo (string settle, string index);
        /// <summary>
        /// Retrieve liquidation history
        /// </summary>
        /// <remarks>
        /// Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;FuturesLiquidate&gt;</returns>
        Task<List<FuturesLiquidate>> ListLiquidatedOrdersAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?));

        /// <summary>
        /// Retrieve liquidation history
        /// </summary>
        /// <remarks>
        /// Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLiquidate&gt;)</returns>
        Task<ApiResponse<List<FuturesLiquidate>>> ListLiquidatedOrdersAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?));
        /// <summary>
        /// Query futures account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of FuturesAccount</returns>
        Task<FuturesAccount> ListFuturesAccountsAsync (string settle);

        /// <summary>
        /// Query futures account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of ApiResponse (FuturesAccount)</returns>
        Task<ApiResponse<FuturesAccount>> ListFuturesAccountsAsyncWithHttpInfo (string settle);
        /// <summary>
        /// Query account book
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate (optional)</param>
        /// <returns>Task of List&lt;FuturesAccountBook&gt;</returns>
        Task<List<FuturesAccountBook>> ListFuturesAccountBookAsync (string settle, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string));

        /// <summary>
        /// Query account book
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesAccountBook&gt;)</returns>
        Task<ApiResponse<List<FuturesAccountBook>>> ListFuturesAccountBookAsyncWithHttpInfo (string settle, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string));
        /// <summary>
        /// List all positions of a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> ListPositionsAsync (string settle);

        /// <summary>
        /// List all positions of a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> ListPositionsAsyncWithHttpInfo (string settle);
        /// <summary>
        /// Get single position
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of Position</returns>
        Task<Position> GetPositionAsync (string settle, string contract);

        /// <summary>
        /// Get single position
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        Task<ApiResponse<Position>> GetPositionAsyncWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Update position margin
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Task of Position</returns>
        Task<Position> UpdatePositionMarginAsync (string settle, string contract, string change);

        /// <summary>
        /// Update position margin
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        Task<ApiResponse<Position>> UpdatePositionMarginAsyncWithHttpInfo (string settle, string contract, string change);
        /// <summary>
        /// Update position leverage
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of Position</returns>
        Task<Position> UpdatePositionLeverageAsync (string settle, string contract, string leverage, string crossLeverageLimit = default(string));

        /// <summary>
        /// Update position leverage
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        Task<ApiResponse<Position>> UpdatePositionLeverageAsyncWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string));
        /// <summary>
        /// Update position risk limit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Task of Position</returns>
        Task<Position> UpdatePositionRiskLimitAsync (string settle, string contract, string riskLimit);

        /// <summary>
        /// Update position risk limit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        Task<ApiResponse<Position>> UpdatePositionRiskLimitAsyncWithHttpInfo (string settle, string contract, string riskLimit);
        /// <summary>
        /// Enable or disable dual mode
        /// </summary>
        /// <remarks>
        /// Before setting dual mode, make sure all positions are closed and no orders are open
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>Task of FuturesAccount</returns>
        Task<FuturesAccount> SetDualModeAsync (string settle, bool dualMode);

        /// <summary>
        /// Enable or disable dual mode
        /// </summary>
        /// <remarks>
        /// Before setting dual mode, make sure all positions are closed and no orders are open
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>Task of ApiResponse (FuturesAccount)</returns>
        Task<ApiResponse<FuturesAccount>> SetDualModeAsyncWithHttpInfo (string settle, bool dualMode);
        /// <summary>
        /// Retrieve position detail in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> GetDualModePositionAsync (string settle, string contract);

        /// <summary>
        /// Retrieve position detail in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> GetDualModePositionAsyncWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Update position margin in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> UpdateDualModePositionMarginAsync (string settle, string contract, string change, string dualSide);

        /// <summary>
        /// Update position margin in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> UpdateDualModePositionMarginAsyncWithHttpInfo (string settle, string contract, string change, string dualSide);
        /// <summary>
        /// Update position leverage in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> UpdateDualModePositionLeverageAsync (string settle, string contract, string leverage, string crossLeverageLimit = default(string));

        /// <summary>
        /// Update position leverage in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> UpdateDualModePositionLeverageAsyncWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string));
        /// <summary>
        /// Update position risk limit in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> UpdateDualModePositionRiskLimitAsync (string settle, string contract, string riskLimit);

        /// <summary>
        /// Update position risk limit in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> UpdateDualModePositionRiskLimitAsyncWithHttpInfo (string settle, string contract, string riskLimit);
        /// <summary>
        /// List futures orders
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        Task<List<FuturesOrder>> ListFuturesOrdersAsync (string settle, string contract, string status, int? limit = default(int?), int? offset = default(int?), string lastId = default(string));

        /// <summary>
        /// List futures orders
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesOrder>>> ListFuturesOrdersAsyncWithHttpInfo (string settle, string contract, string status, int? limit = default(int?), int? offset = default(int?), string lastId = default(string));
        /// <summary>
        /// Create a futures order
        /// </summary>
        /// <remarks>
        /// - Creating futures orders requires &#x60;size&#x60;, which is number of contracts instead of currency amount. You can use &#x60;quanto_multiplier&#x60; in contract detail response to know how much currency 1 size contract represents - Zero-filled order cannot be retrieved 10 minutes after order cancellation. You will get a 404 not found for such orders - Set &#x60;reduce_only&#x60; to &#x60;true&#x60; can keep the position from changing side when reducing position size - In single position mode, to close a position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual position mode, to close one side position, you need to set &#x60;auto_size&#x60; side, &#x60;reduce_only&#x60; to true and &#x60;size&#x60; to 0
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>Task of FuturesOrder</returns>
        Task<FuturesOrder> CreateFuturesOrderAsync (string settle, FuturesOrder futuresOrder);

        /// <summary>
        /// Create a futures order
        /// </summary>
        /// <remarks>
        /// - Creating futures orders requires &#x60;size&#x60;, which is number of contracts instead of currency amount. You can use &#x60;quanto_multiplier&#x60; in contract detail response to know how much currency 1 size contract represents - Zero-filled order cannot be retrieved 10 minutes after order cancellation. You will get a 404 not found for such orders - Set &#x60;reduce_only&#x60; to &#x60;true&#x60; can keep the position from changing side when reducing position size - In single position mode, to close a position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual position mode, to close one side position, you need to set &#x60;auto_size&#x60; side, &#x60;reduce_only&#x60; to true and &#x60;size&#x60; to 0
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        Task<ApiResponse<FuturesOrder>> CreateFuturesOrderAsyncWithHttpInfo (string settle, FuturesOrder futuresOrder);
        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="side">All bids or asks. Both included if not specified (optional)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        Task<List<FuturesOrder>> CancelFuturesOrdersAsync (string settle, string contract, string side = default(string));

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="side">All bids or asks. Both included if not specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesOrder>>> CancelFuturesOrdersAsyncWithHttpInfo (string settle, string contract, string side = default(string));
        /// <summary>
        /// Create a batch of futures orders
        /// </summary>
        /// <remarks>
        /// - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>Task of List&lt;BatchFuturesOrder&gt;</returns>
        Task<List<BatchFuturesOrder>> CreateBatchFuturesOrderAsync (string settle, List<FuturesOrder> futuresOrder);

        /// <summary>
        /// Create a batch of futures orders
        /// </summary>
        /// <remarks>
        /// - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>Task of ApiResponse (List&lt;BatchFuturesOrder&gt;)</returns>
        Task<ApiResponse<List<BatchFuturesOrder>>> CreateBatchFuturesOrderAsyncWithHttpInfo (string settle, List<FuturesOrder> futuresOrder);
        /// <summary>
        /// Get a single order
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of FuturesOrder</returns>
        Task<FuturesOrder> GetFuturesOrderAsync (string settle, string orderId);

        /// <summary>
        /// Get a single order
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        Task<ApiResponse<FuturesOrder>> GetFuturesOrderAsyncWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// Amend an order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <returns>Task of FuturesOrder</returns>
        Task<FuturesOrder> AmendFuturesOrderAsync (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment);

        /// <summary>
        /// Amend an order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        Task<ApiResponse<FuturesOrder>> AmendFuturesOrderAsyncWithHttpInfo (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment);
        /// <summary>
        /// Cancel a single order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of FuturesOrder</returns>
        Task<FuturesOrder> CancelFuturesOrderAsync (string settle, string orderId);

        /// <summary>
        /// Cancel a single order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        Task<ApiResponse<FuturesOrder>> CancelFuturesOrderAsyncWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// List personal trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of List&lt;MyFuturesTrade&gt;</returns>
        Task<List<MyFuturesTrade>> GetMyTradesAsync (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));

        /// <summary>
        /// List personal trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;MyFuturesTrade&gt;)</returns>
        Task<ApiResponse<List<MyFuturesTrade>>> GetMyTradesAsyncWithHttpInfo (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));
        /// <summary>
        /// List personal trading history by time range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;MyFuturesTrade&gt;</returns>
        Task<List<MyFuturesTrade>> GetMyTradesWithTimeRangeAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List personal trading history by time range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;MyFuturesTrade&gt;)</returns>
        Task<ApiResponse<List<MyFuturesTrade>>> GetMyTradesWithTimeRangeAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// List position close history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>Task of List&lt;PositionClose&gt;</returns>
        Task<List<PositionClose>> ListPositionCloseAsync (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// List position close history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;PositionClose&gt;)</returns>
        Task<ApiResponse<List<PositionClose>>> ListPositionCloseAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// List liquidation history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesLiquidate&gt;</returns>
        Task<List<FuturesLiquidate>> ListLiquidatesAsync (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));

        /// <summary>
        /// List liquidation history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLiquidate&gt;)</returns>
        Task<ApiResponse<List<FuturesLiquidate>>> ListLiquidatesAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));
        /// <summary>
        /// List Auto-Deleveraging History
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesAutoDeleverage&gt;</returns>
        Task<List<FuturesAutoDeleverage>> ListAutoDeleveragesAsync (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));

        /// <summary>
        /// List Auto-Deleveraging History
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesAutoDeleverage&gt;)</returns>
        Task<ApiResponse<List<FuturesAutoDeleverage>>> ListAutoDeleveragesAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));
        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>Task of TriggerTime</returns>
        Task<TriggerTime> CountdownCancelAllFuturesAsync (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask);

        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>Task of ApiResponse (TriggerTime)</returns>
        Task<ApiResponse<TriggerTime>> CountdownCancelAllFuturesAsyncWithHttpInfo (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask);
        /// <summary>
        /// List all auto orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        Task<List<FuturesPriceTriggeredOrder>> ListPriceTriggeredOrdersAsync (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List all auto orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPriceTriggeredOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesPriceTriggeredOrder>>> ListPriceTriggeredOrdersAsyncWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Create a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>Task of TriggerOrderResponse</returns>
        Task<TriggerOrderResponse> CreatePriceTriggeredOrderAsync (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder);

        /// <summary>
        /// Create a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>Task of ApiResponse (TriggerOrderResponse)</returns>
        Task<ApiResponse<TriggerOrderResponse>> CreatePriceTriggeredOrderAsyncWithHttpInfo (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder);
        /// <summary>
        /// Cancel all open orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        Task<List<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderListAsync (string settle, string contract);

        /// <summary>
        /// Cancel all open orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPriceTriggeredOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesPriceTriggeredOrder>>> CancelPriceTriggeredOrderListAsyncWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Get a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of FuturesPriceTriggeredOrder</returns>
        Task<FuturesPriceTriggeredOrder> GetPriceTriggeredOrderAsync (string settle, string orderId);

        /// <summary>
        /// Get a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of ApiResponse (FuturesPriceTriggeredOrder)</returns>
        Task<ApiResponse<FuturesPriceTriggeredOrder>> GetPriceTriggeredOrderAsyncWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// cancel a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of FuturesPriceTriggeredOrder</returns>
        Task<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderAsync (string settle, string orderId);

        /// <summary>
        /// cancel a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of ApiResponse (FuturesPriceTriggeredOrder)</returns>
        Task<ApiResponse<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderAsyncWithHttpInfo (string settle, string orderId);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFuturesApi : IFuturesApiSync, IFuturesApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class FuturesApi : IFuturesApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public FuturesApi() : this((string) null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public FuturesApi(string basePath)
        {
            this.Configuration = Io.Gate.GateApi.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            this.Client = new ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Io.Gate.GateApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public FuturesApi(Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Io.Gate.GateApi.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Io.Gate.GateApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public FuturesApi(ISynchronousClient client,IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            if(client == null) throw new ArgumentNullException("client");
            if(asyncClient == null) throw new ArgumentNullException("asyncClient");
            if(configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Io.Gate.GateApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// List all futures contracts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>List&lt;Contract&gt;</returns>
        public List<Contract> ListFuturesContracts (string settle)
        {
             ApiResponse<List<Contract>> localVarResponse = ListFuturesContractsWithHttpInfo(settle);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List all futures contracts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>ApiResponse of List&lt;Contract&gt;</returns>
        public ApiResponse<List<Contract>> ListFuturesContractsWithHttpInfo (string settle)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesContracts");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Contract>>("/futures/{settle}/contracts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesContracts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all futures contracts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of List&lt;Contract&gt;</returns>
        public async Task<List<Contract>> ListFuturesContractsAsync (string settle)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Contract>> localVarResponse = await ListFuturesContractsAsyncWithHttpInfo(settle);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List all futures contracts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of ApiResponse (List&lt;Contract&gt;)</returns>
        public async Task<ApiResponse<List<Contract>>> ListFuturesContractsAsyncWithHttpInfo (string settle)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesContracts");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Contract>>("/futures/{settle}/contracts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesContracts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single contract 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Contract</returns>
        public Contract GetFuturesContract (string settle, string contract)
        {
             ApiResponse<Contract> localVarResponse = GetFuturesContractWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single contract 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of Contract</returns>
        public ApiResponse<Contract> GetFuturesContractWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesContract");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetFuturesContract");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<Contract>("/futures/{settle}/contracts/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single contract 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of Contract</returns>
        public async Task<Contract> GetFuturesContractAsync (string settle, string contract)
        {
             Io.Gate.GateApi.Client.ApiResponse<Contract> localVarResponse = await GetFuturesContractAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single contract 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (Contract)</returns>
        public async Task<ApiResponse<Contract>> GetFuturesContractAsyncWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesContract");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetFuturesContract");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Contract>("/futures/{settle}/contracts/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures order book Bids will be sorted by price from high to low, while asks sorted reversely
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to 0)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>FuturesOrderBook</returns>
        public FuturesOrderBook ListFuturesOrderBook (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
             ApiResponse<FuturesOrderBook> localVarResponse = ListFuturesOrderBookWithHttpInfo(settle, contract, interval, limit, withId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Futures order book Bids will be sorted by price from high to low, while asks sorted reversely
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to 0)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>ApiResponse of FuturesOrderBook</returns>
        public ApiResponse<FuturesOrderBook> ListFuturesOrderBookWithHttpInfo (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesOrderBook");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesOrderBook");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (withId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "with_id", withId));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesOrderBook>("/futures/{settle}/order_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesOrderBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures order book Bids will be sorted by price from high to low, while asks sorted reversely
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to 0)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>Task of FuturesOrderBook</returns>
        public async Task<FuturesOrderBook> ListFuturesOrderBookAsync (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrderBook> localVarResponse = await ListFuturesOrderBookAsyncWithHttpInfo(settle, contract, interval, limit, withId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Futures order book Bids will be sorted by price from high to low, while asks sorted reversely
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to 0)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>Task of ApiResponse (FuturesOrderBook)</returns>
        public async Task<ApiResponse<FuturesOrderBook>> ListFuturesOrderBookAsyncWithHttpInfo (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesOrderBook");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesOrderBook");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (withId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "with_id", withId));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesOrderBook>("/futures/{settle}/order_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesOrderBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>List&lt;FuturesTrade&gt;</returns>
        public List<FuturesTrade> ListFuturesTrades (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?))
        {
             ApiResponse<List<FuturesTrade>> localVarResponse = ListFuturesTradesWithHttpInfo(settle, contract, limit, offset, lastId, from, to);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Futures trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesTrade&gt;</returns>
        public ApiResponse<List<FuturesTrade>> ListFuturesTradesWithHttpInfo (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesTrades");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesTrades");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesTrade>>("/futures/{settle}/trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>Task of List&lt;FuturesTrade&gt;</returns>
        public async Task<List<FuturesTrade>> ListFuturesTradesAsync (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesTrade>> localVarResponse = await ListFuturesTradesAsyncWithHttpInfo(settle, contract, limit, offset, lastId, from, to);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Futures trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesTrade&gt;)</returns>
        public async Task<ApiResponse<List<FuturesTrade>>> ListFuturesTradesAsyncWithHttpInfo (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesTrades");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesTrades");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesTrade>>("/futures/{settle}/trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get futures candlesticks Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0 (optional, default to 5m)</param>
        /// <returns>List&lt;FuturesCandlestick&gt;</returns>
        public List<FuturesCandlestick> ListFuturesCandlesticks (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
             ApiResponse<List<FuturesCandlestick>> localVarResponse = ListFuturesCandlesticksWithHttpInfo(settle, contract, from, to, limit, interval);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get futures candlesticks Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0 (optional, default to 5m)</param>
        /// <returns>ApiResponse of List&lt;FuturesCandlestick&gt;</returns>
        public ApiResponse<List<FuturesCandlestick>> ListFuturesCandlesticksWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesCandlesticks");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesCandlesticks");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesCandlestick>>("/futures/{settle}/candlesticks", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesCandlesticks", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get futures candlesticks Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0 (optional, default to 5m)</param>
        /// <returns>Task of List&lt;FuturesCandlestick&gt;</returns>
        public async Task<List<FuturesCandlestick>> ListFuturesCandlesticksAsync (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesCandlestick>> localVarResponse = await ListFuturesCandlesticksAsyncWithHttpInfo(settle, contract, from, to, limit, interval);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get futures candlesticks Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0 (optional, default to 5m)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesCandlestick&gt;)</returns>
        public async Task<ApiResponse<List<FuturesCandlestick>>> ListFuturesCandlesticksAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesCandlesticks");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesCandlesticks");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesCandlestick>>("/futures/{settle}/candlesticks", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesCandlesticks", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Premium Index K-Line Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to 5m)</param>
        /// <returns>List&lt;FuturesPremiumIndex&gt;</returns>
        public List<FuturesPremiumIndex> ListFuturesPremiumIndex (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
             ApiResponse<List<FuturesPremiumIndex>> localVarResponse = ListFuturesPremiumIndexWithHttpInfo(settle, contract, from, to, limit, interval);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Premium Index K-Line Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to 5m)</param>
        /// <returns>ApiResponse of List&lt;FuturesPremiumIndex&gt;</returns>
        public ApiResponse<List<FuturesPremiumIndex>> ListFuturesPremiumIndexWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesPremiumIndex");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesPremiumIndex");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesPremiumIndex>>("/futures/{settle}/premium_index", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesPremiumIndex", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Premium Index K-Line Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to 5m)</param>
        /// <returns>Task of List&lt;FuturesPremiumIndex&gt;</returns>
        public async Task<List<FuturesPremiumIndex>> ListFuturesPremiumIndexAsync (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesPremiumIndex>> localVarResponse = await ListFuturesPremiumIndexAsyncWithHttpInfo(settle, contract, from, to, limit, interval);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Premium Index K-Line Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to 5m)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPremiumIndex&gt;)</returns>
        public async Task<ApiResponse<List<FuturesPremiumIndex>>> ListFuturesPremiumIndexAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesPremiumIndex");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesPremiumIndex");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesPremiumIndex>>("/futures/{settle}/premium_index", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesPremiumIndex", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List futures tickers 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>List&lt;FuturesTicker&gt;</returns>
        public List<FuturesTicker> ListFuturesTickers (string settle, string contract = default(string))
        {
             ApiResponse<List<FuturesTicker>> localVarResponse = ListFuturesTickersWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List futures tickers 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesTicker&gt;</returns>
        public ApiResponse<List<FuturesTicker>> ListFuturesTickersWithHttpInfo (string settle, string contract = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesTickers");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesTicker>>("/futures/{settle}/tickers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesTickers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List futures tickers 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of List&lt;FuturesTicker&gt;</returns>
        public async Task<List<FuturesTicker>> ListFuturesTickersAsync (string settle, string contract = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesTicker>> localVarResponse = await ListFuturesTickersAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List futures tickers 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesTicker&gt;)</returns>
        public async Task<ApiResponse<List<FuturesTicker>>> ListFuturesTickersAsyncWithHttpInfo (string settle, string contract = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesTickers");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesTicker>>("/futures/{settle}/tickers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesTickers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Funding rate history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;FundingRateRecord&gt;</returns>
        public List<FundingRateRecord> ListFuturesFundingRateHistory (string settle, string contract, int? limit = default(int?))
        {
             ApiResponse<List<FundingRateRecord>> localVarResponse = ListFuturesFundingRateHistoryWithHttpInfo(settle, contract, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Funding rate history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;FundingRateRecord&gt;</returns>
        public ApiResponse<List<FundingRateRecord>> ListFuturesFundingRateHistoryWithHttpInfo (string settle, string contract, int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesFundingRateHistory");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesFundingRateHistory");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FundingRateRecord>>("/futures/{settle}/funding_rate", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesFundingRateHistory", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Funding rate history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;FundingRateRecord&gt;</returns>
        public async Task<List<FundingRateRecord>> ListFuturesFundingRateHistoryAsync (string settle, string contract, int? limit = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FundingRateRecord>> localVarResponse = await ListFuturesFundingRateHistoryAsyncWithHttpInfo(settle, contract, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Funding rate history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;FundingRateRecord&gt;)</returns>
        public async Task<ApiResponse<List<FundingRateRecord>>> ListFuturesFundingRateHistoryAsyncWithHttpInfo (string settle, string contract, int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesFundingRateHistory");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesFundingRateHistory");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FundingRateRecord>>("/futures/{settle}/funding_rate", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesFundingRateHistory", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures insurance balance history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;InsuranceRecord&gt;</returns>
        public List<InsuranceRecord> ListFuturesInsuranceLedger (string settle, int? limit = default(int?))
        {
             ApiResponse<List<InsuranceRecord>> localVarResponse = ListFuturesInsuranceLedgerWithHttpInfo(settle, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Futures insurance balance history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;InsuranceRecord&gt;</returns>
        public ApiResponse<List<InsuranceRecord>> ListFuturesInsuranceLedgerWithHttpInfo (string settle, int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesInsuranceLedger");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<InsuranceRecord>>("/futures/{settle}/insurance", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesInsuranceLedger", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures insurance balance history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;InsuranceRecord&gt;</returns>
        public async Task<List<InsuranceRecord>> ListFuturesInsuranceLedgerAsync (string settle, int? limit = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<InsuranceRecord>> localVarResponse = await ListFuturesInsuranceLedgerAsyncWithHttpInfo(settle, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Futures insurance balance history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;InsuranceRecord&gt;)</returns>
        public async Task<ApiResponse<List<InsuranceRecord>>> ListFuturesInsuranceLedgerAsyncWithHttpInfo (string settle, int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesInsuranceLedger");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<InsuranceRecord>>("/futures/{settle}/insurance", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesInsuranceLedger", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures stats 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to 5m)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>List&lt;ContractStat&gt;</returns>
        public List<ContractStat> ListContractStats (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?))
        {
             ApiResponse<List<ContractStat>> localVarResponse = ListContractStatsWithHttpInfo(settle, contract, from, interval, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Futures stats 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to 5m)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>ApiResponse of List&lt;ContractStat&gt;</returns>
        public ApiResponse<List<ContractStat>> ListContractStatsWithHttpInfo (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListContractStats");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListContractStats");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ContractStat>>("/futures/{settle}/contract_stats", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListContractStats", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures stats 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to 5m)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>Task of List&lt;ContractStat&gt;</returns>
        public async Task<List<ContractStat>> ListContractStatsAsync (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<ContractStat>> localVarResponse = await ListContractStatsAsyncWithHttpInfo(settle, contract, from, interval, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Futures stats 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to 5m)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>Task of ApiResponse (List&lt;ContractStat&gt;)</returns>
        public async Task<ApiResponse<List<ContractStat>>> ListContractStatsAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListContractStats");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListContractStats");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ContractStat>>("/futures/{settle}/contract_stats", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListContractStats", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get index constituents 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>FuturesIndexConstituents</returns>
        public FuturesIndexConstituents GetIndexConstituents (string settle, string index)
        {
             ApiResponse<FuturesIndexConstituents> localVarResponse = GetIndexConstituentsWithHttpInfo(settle, index);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get index constituents 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>ApiResponse of FuturesIndexConstituents</returns>
        public ApiResponse<FuturesIndexConstituents> GetIndexConstituentsWithHttpInfo (string settle, string index)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetIndexConstituents");

            // verify the required parameter 'index' is set
            if (index == null)
                throw new ApiException(400, "Missing required parameter 'index' when calling FuturesApi->GetIndexConstituents");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesIndexConstituents>("/futures/{settle}/index_constituents/{index}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIndexConstituents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get index constituents 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>Task of FuturesIndexConstituents</returns>
        public async Task<FuturesIndexConstituents> GetIndexConstituentsAsync (string settle, string index)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesIndexConstituents> localVarResponse = await GetIndexConstituentsAsyncWithHttpInfo(settle, index);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get index constituents 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>Task of ApiResponse (FuturesIndexConstituents)</returns>
        public async Task<ApiResponse<FuturesIndexConstituents>> GetIndexConstituentsAsyncWithHttpInfo (string settle, string index)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetIndexConstituents");

            // verify the required parameter 'index' is set
            if (index == null)
                throw new ApiException(400, "Missing required parameter 'index' when calling FuturesApi->GetIndexConstituents");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesIndexConstituents>("/futures/{settle}/index_constituents/{index}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIndexConstituents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve liquidation history Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;FuturesLiquidate&gt;</returns>
        public List<FuturesLiquidate> ListLiquidatedOrders (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?))
        {
             ApiResponse<List<FuturesLiquidate>> localVarResponse = ListLiquidatedOrdersWithHttpInfo(settle, contract, from, to, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve liquidation history Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;FuturesLiquidate&gt;</returns>
        public ApiResponse<List<FuturesLiquidate>> ListLiquidatedOrdersWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListLiquidatedOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesLiquidate>>("/futures/{settle}/liq_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLiquidatedOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve liquidation history Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;FuturesLiquidate&gt;</returns>
        public async Task<List<FuturesLiquidate>> ListLiquidatedOrdersAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesLiquidate>> localVarResponse = await ListLiquidatedOrdersAsyncWithHttpInfo(settle, contract, from, to, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieve liquidation history Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLiquidate&gt;)</returns>
        public async Task<ApiResponse<List<FuturesLiquidate>>> ListLiquidatedOrdersAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListLiquidatedOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesLiquidate>>("/futures/{settle}/liq_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLiquidatedOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query futures account 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>FuturesAccount</returns>
        public FuturesAccount ListFuturesAccounts (string settle)
        {
             ApiResponse<FuturesAccount> localVarResponse = ListFuturesAccountsWithHttpInfo(settle);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query futures account 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>ApiResponse of FuturesAccount</returns>
        public ApiResponse<FuturesAccount> ListFuturesAccountsWithHttpInfo (string settle)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesAccounts");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesAccount>("/futures/{settle}/accounts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesAccounts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query futures account 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of FuturesAccount</returns>
        public async Task<FuturesAccount> ListFuturesAccountsAsync (string settle)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesAccount> localVarResponse = await ListFuturesAccountsAsyncWithHttpInfo(settle);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query futures account 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of ApiResponse (FuturesAccount)</returns>
        public async Task<ApiResponse<FuturesAccount>> ListFuturesAccountsAsyncWithHttpInfo (string settle)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesAccounts");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesAccount>("/futures/{settle}/accounts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesAccounts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query account book 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate (optional)</param>
        /// <returns>List&lt;FuturesAccountBook&gt;</returns>
        public List<FuturesAccountBook> ListFuturesAccountBook (string settle, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string))
        {
             ApiResponse<List<FuturesAccountBook>> localVarResponse = ListFuturesAccountBookWithHttpInfo(settle, limit, from, to, type);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query account book 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesAccountBook&gt;</returns>
        public ApiResponse<List<FuturesAccountBook>> ListFuturesAccountBookWithHttpInfo (string settle, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesAccountBook");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (type != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "type", type));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesAccountBook>>("/futures/{settle}/account_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesAccountBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query account book 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate (optional)</param>
        /// <returns>Task of List&lt;FuturesAccountBook&gt;</returns>
        public async Task<List<FuturesAccountBook>> ListFuturesAccountBookAsync (string settle, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesAccountBook>> localVarResponse = await ListFuturesAccountBookAsyncWithHttpInfo(settle, limit, from, to, type);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query account book 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type: - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesAccountBook&gt;)</returns>
        public async Task<ApiResponse<List<FuturesAccountBook>>> ListFuturesAccountBookAsyncWithHttpInfo (string settle, int? limit = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesAccountBook");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (type != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "type", type));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesAccountBook>>("/futures/{settle}/account_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesAccountBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all positions of a user 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> ListPositions (string settle)
        {
             ApiResponse<List<Position>> localVarResponse = ListPositionsWithHttpInfo(settle);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List all positions of a user 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> ListPositionsWithHttpInfo (string settle)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPositions");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Position>>("/futures/{settle}/positions", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPositions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all positions of a user 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> ListPositionsAsync (string settle)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await ListPositionsAsyncWithHttpInfo(settle);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List all positions of a user 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> ListPositionsAsyncWithHttpInfo (string settle)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPositions");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Position>>("/futures/{settle}/positions", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPositions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get single position 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Position</returns>
        public Position GetPosition (string settle, string contract)
        {
             ApiResponse<Position> localVarResponse = GetPositionWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get single position 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of Position</returns>
        public ApiResponse<Position> GetPositionWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetPosition");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetPosition");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<Position>("/futures/{settle}/positions/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPosition", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get single position 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of Position</returns>
        public async Task<Position> GetPositionAsync (string settle, string contract)
        {
             Io.Gate.GateApi.Client.ApiResponse<Position> localVarResponse = await GetPositionAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get single position 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        public async Task<ApiResponse<Position>> GetPositionAsyncWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetPosition");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetPosition");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Position>("/futures/{settle}/positions/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPosition", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position margin 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Position</returns>
        public Position UpdatePositionMargin (string settle, string contract, string change)
        {
             ApiResponse<Position> localVarResponse = UpdatePositionMarginWithHttpInfo(settle, contract, change);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position margin 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>ApiResponse of Position</returns>
        public ApiResponse<Position> UpdatePositionMarginWithHttpInfo (string settle, string contract, string change)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionMargin");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionMargin");

            // verify the required parameter 'change' is set
            if (change == null)
                throw new ApiException(400, "Missing required parameter 'change' when calling FuturesApi->UpdatePositionMargin");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "change", change));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<Position>("/futures/{settle}/positions/{contract}/margin", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionMargin", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position margin 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Task of Position</returns>
        public async Task<Position> UpdatePositionMarginAsync (string settle, string contract, string change)
        {
             Io.Gate.GateApi.Client.ApiResponse<Position> localVarResponse = await UpdatePositionMarginAsyncWithHttpInfo(settle, contract, change);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position margin 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        public async Task<ApiResponse<Position>> UpdatePositionMarginAsyncWithHttpInfo (string settle, string contract, string change)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionMargin");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionMargin");

            // verify the required parameter 'change' is set
            if (change == null)
                throw new ApiException(400, "Missing required parameter 'change' when calling FuturesApi->UpdatePositionMargin");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "change", change));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Position>("/futures/{settle}/positions/{contract}/margin", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionMargin", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position leverage 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Position</returns>
        public Position UpdatePositionLeverage (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
             ApiResponse<Position> localVarResponse = UpdatePositionLeverageWithHttpInfo(settle, contract, leverage, crossLeverageLimit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position leverage 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>ApiResponse of Position</returns>
        public ApiResponse<Position> UpdatePositionLeverageWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionLeverage");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionLeverage");

            // verify the required parameter 'leverage' is set
            if (leverage == null)
                throw new ApiException(400, "Missing required parameter 'leverage' when calling FuturesApi->UpdatePositionLeverage");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "leverage", leverage));
            if (crossLeverageLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "cross_leverage_limit", crossLeverageLimit));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<Position>("/futures/{settle}/positions/{contract}/leverage", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionLeverage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position leverage 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of Position</returns>
        public async Task<Position> UpdatePositionLeverageAsync (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<Position> localVarResponse = await UpdatePositionLeverageAsyncWithHttpInfo(settle, contract, leverage, crossLeverageLimit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position leverage 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        public async Task<ApiResponse<Position>> UpdatePositionLeverageAsyncWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionLeverage");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionLeverage");

            // verify the required parameter 'leverage' is set
            if (leverage == null)
                throw new ApiException(400, "Missing required parameter 'leverage' when calling FuturesApi->UpdatePositionLeverage");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "leverage", leverage));
            if (crossLeverageLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "cross_leverage_limit", crossLeverageLimit));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Position>("/futures/{settle}/positions/{contract}/leverage", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionLeverage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position risk limit 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Position</returns>
        public Position UpdatePositionRiskLimit (string settle, string contract, string riskLimit)
        {
             ApiResponse<Position> localVarResponse = UpdatePositionRiskLimitWithHttpInfo(settle, contract, riskLimit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position risk limit 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>ApiResponse of Position</returns>
        public ApiResponse<Position> UpdatePositionRiskLimitWithHttpInfo (string settle, string contract, string riskLimit)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionRiskLimit");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionRiskLimit");

            // verify the required parameter 'riskLimit' is set
            if (riskLimit == null)
                throw new ApiException(400, "Missing required parameter 'riskLimit' when calling FuturesApi->UpdatePositionRiskLimit");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "risk_limit", riskLimit));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<Position>("/futures/{settle}/positions/{contract}/risk_limit", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionRiskLimit", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position risk limit 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Task of Position</returns>
        public async Task<Position> UpdatePositionRiskLimitAsync (string settle, string contract, string riskLimit)
        {
             Io.Gate.GateApi.Client.ApiResponse<Position> localVarResponse = await UpdatePositionRiskLimitAsyncWithHttpInfo(settle, contract, riskLimit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position risk limit 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        public async Task<ApiResponse<Position>> UpdatePositionRiskLimitAsyncWithHttpInfo (string settle, string contract, string riskLimit)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionRiskLimit");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionRiskLimit");

            // verify the required parameter 'riskLimit' is set
            if (riskLimit == null)
                throw new ApiException(400, "Missing required parameter 'riskLimit' when calling FuturesApi->UpdatePositionRiskLimit");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "risk_limit", riskLimit));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Position>("/futures/{settle}/positions/{contract}/risk_limit", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionRiskLimit", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Enable or disable dual mode Before setting dual mode, make sure all positions are closed and no orders are open
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>FuturesAccount</returns>
        public FuturesAccount SetDualMode (string settle, bool dualMode)
        {
             ApiResponse<FuturesAccount> localVarResponse = SetDualModeWithHttpInfo(settle, dualMode);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Enable or disable dual mode Before setting dual mode, make sure all positions are closed and no orders are open
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>ApiResponse of FuturesAccount</returns>
        public ApiResponse<FuturesAccount> SetDualModeWithHttpInfo (string settle, bool dualMode)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->SetDualMode");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "dual_mode", dualMode));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<FuturesAccount>("/futures/{settle}/dual_mode", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetDualMode", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Enable or disable dual mode Before setting dual mode, make sure all positions are closed and no orders are open
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>Task of FuturesAccount</returns>
        public async Task<FuturesAccount> SetDualModeAsync (string settle, bool dualMode)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesAccount> localVarResponse = await SetDualModeAsyncWithHttpInfo(settle, dualMode);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Enable or disable dual mode Before setting dual mode, make sure all positions are closed and no orders are open
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>Task of ApiResponse (FuturesAccount)</returns>
        public async Task<ApiResponse<FuturesAccount>> SetDualModeAsyncWithHttpInfo (string settle, bool dualMode)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->SetDualMode");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "dual_mode", dualMode));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<FuturesAccount>("/futures/{settle}/dual_mode", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetDualMode", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve position detail in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> GetDualModePosition (string settle, string contract)
        {
             ApiResponse<List<Position>> localVarResponse = GetDualModePositionWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve position detail in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> GetDualModePositionWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetDualModePosition");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetDualModePosition");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDualModePosition", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve position detail in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> GetDualModePositionAsync (string settle, string contract)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await GetDualModePositionAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieve position detail in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> GetDualModePositionAsyncWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetDualModePosition");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetDualModePosition");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDualModePosition", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position margin in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> UpdateDualModePositionMargin (string settle, string contract, string change, string dualSide)
        {
             ApiResponse<List<Position>> localVarResponse = UpdateDualModePositionMarginWithHttpInfo(settle, contract, change, dualSide);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position margin in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> UpdateDualModePositionMarginWithHttpInfo (string settle, string contract, string change, string dualSide)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'change' is set
            if (change == null)
                throw new ApiException(400, "Missing required parameter 'change' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'dualSide' is set
            if (dualSide == null)
                throw new ApiException(400, "Missing required parameter 'dualSide' when calling FuturesApi->UpdateDualModePositionMargin");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "change", change));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "dual_side", dualSide));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/margin", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionMargin", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position margin in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> UpdateDualModePositionMarginAsync (string settle, string contract, string change, string dualSide)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await UpdateDualModePositionMarginAsyncWithHttpInfo(settle, contract, change, dualSide);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position margin in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> UpdateDualModePositionMarginAsyncWithHttpInfo (string settle, string contract, string change, string dualSide)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'change' is set
            if (change == null)
                throw new ApiException(400, "Missing required parameter 'change' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'dualSide' is set
            if (dualSide == null)
                throw new ApiException(400, "Missing required parameter 'dualSide' when calling FuturesApi->UpdateDualModePositionMargin");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "change", change));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "dual_side", dualSide));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/margin", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionMargin", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position leverage in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> UpdateDualModePositionLeverage (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
             ApiResponse<List<Position>> localVarResponse = UpdateDualModePositionLeverageWithHttpInfo(settle, contract, leverage, crossLeverageLimit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position leverage in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> UpdateDualModePositionLeverageWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionLeverage");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionLeverage");

            // verify the required parameter 'leverage' is set
            if (leverage == null)
                throw new ApiException(400, "Missing required parameter 'leverage' when calling FuturesApi->UpdateDualModePositionLeverage");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "leverage", leverage));
            if (crossLeverageLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "cross_leverage_limit", crossLeverageLimit));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/leverage", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionLeverage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position leverage in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> UpdateDualModePositionLeverageAsync (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await UpdateDualModePositionLeverageAsyncWithHttpInfo(settle, contract, leverage, crossLeverageLimit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position leverage in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> UpdateDualModePositionLeverageAsyncWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionLeverage");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionLeverage");

            // verify the required parameter 'leverage' is set
            if (leverage == null)
                throw new ApiException(400, "Missing required parameter 'leverage' when calling FuturesApi->UpdateDualModePositionLeverage");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "leverage", leverage));
            if (crossLeverageLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "cross_leverage_limit", crossLeverageLimit));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/leverage", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionLeverage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position risk limit in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> UpdateDualModePositionRiskLimit (string settle, string contract, string riskLimit)
        {
             ApiResponse<List<Position>> localVarResponse = UpdateDualModePositionRiskLimitWithHttpInfo(settle, contract, riskLimit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position risk limit in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> UpdateDualModePositionRiskLimitWithHttpInfo (string settle, string contract, string riskLimit)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            // verify the required parameter 'riskLimit' is set
            if (riskLimit == null)
                throw new ApiException(400, "Missing required parameter 'riskLimit' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "risk_limit", riskLimit));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/risk_limit", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionRiskLimit", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position risk limit in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> UpdateDualModePositionRiskLimitAsync (string settle, string contract, string riskLimit)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await UpdateDualModePositionRiskLimitAsyncWithHttpInfo(settle, contract, riskLimit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position risk limit in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New position risk limit</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> UpdateDualModePositionRiskLimitAsyncWithHttpInfo (string settle, string contract, string riskLimit)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            // verify the required parameter 'riskLimit' is set
            if (riskLimit == null)
                throw new ApiException(400, "Missing required parameter 'riskLimit' when calling FuturesApi->UpdateDualModePositionRiskLimit");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "risk_limit", riskLimit));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/risk_limit", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionRiskLimit", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List futures orders Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        public List<FuturesOrder> ListFuturesOrders (string settle, string contract, string status, int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
             ApiResponse<List<FuturesOrder>> localVarResponse = ListFuturesOrdersWithHttpInfo(settle, contract, status, limit, offset, lastId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List futures orders Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        public ApiResponse<List<FuturesOrder>> ListFuturesOrdersWithHttpInfo (string settle, string contract, string status, int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesOrders");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling FuturesApi->ListFuturesOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesOrder>>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List futures orders Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        public async Task<List<FuturesOrder>> ListFuturesOrdersAsync (string settle, string contract, string status, int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesOrder>> localVarResponse = await ListFuturesOrdersAsyncWithHttpInfo(settle, contract, status, limit, offset, lastId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List futures orders Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesOrder>>> ListFuturesOrdersAsyncWithHttpInfo (string settle, string contract, string status, int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesOrders");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling FuturesApi->ListFuturesOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesOrder>>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a futures order - Creating futures orders requires &#x60;size&#x60;, which is number of contracts instead of currency amount. You can use &#x60;quanto_multiplier&#x60; in contract detail response to know how much currency 1 size contract represents - Zero-filled order cannot be retrieved 10 minutes after order cancellation. You will get a 404 not found for such orders - Set &#x60;reduce_only&#x60; to &#x60;true&#x60; can keep the position from changing side when reducing position size - In single position mode, to close a position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual position mode, to close one side position, you need to set &#x60;auto_size&#x60; side, &#x60;reduce_only&#x60; to true and &#x60;size&#x60; to 0
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>FuturesOrder</returns>
        public FuturesOrder CreateFuturesOrder (string settle, FuturesOrder futuresOrder)
        {
             ApiResponse<FuturesOrder> localVarResponse = CreateFuturesOrderWithHttpInfo(settle, futuresOrder);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a futures order - Creating futures orders requires &#x60;size&#x60;, which is number of contracts instead of currency amount. You can use &#x60;quanto_multiplier&#x60; in contract detail response to know how much currency 1 size contract represents - Zero-filled order cannot be retrieved 10 minutes after order cancellation. You will get a 404 not found for such orders - Set &#x60;reduce_only&#x60; to &#x60;true&#x60; can keep the position from changing side when reducing position size - In single position mode, to close a position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual position mode, to close one side position, you need to set &#x60;auto_size&#x60; side, &#x60;reduce_only&#x60; to true and &#x60;size&#x60; to 0
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        public ApiResponse<FuturesOrder> CreateFuturesOrderWithHttpInfo (string settle, FuturesOrder futuresOrder)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreateFuturesOrder");

            // verify the required parameter 'futuresOrder' is set
            if (futuresOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrder' when calling FuturesApi->CreateFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = futuresOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<FuturesOrder>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a futures order - Creating futures orders requires &#x60;size&#x60;, which is number of contracts instead of currency amount. You can use &#x60;quanto_multiplier&#x60; in contract detail response to know how much currency 1 size contract represents - Zero-filled order cannot be retrieved 10 minutes after order cancellation. You will get a 404 not found for such orders - Set &#x60;reduce_only&#x60; to &#x60;true&#x60; can keep the position from changing side when reducing position size - In single position mode, to close a position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual position mode, to close one side position, you need to set &#x60;auto_size&#x60; side, &#x60;reduce_only&#x60; to true and &#x60;size&#x60; to 0
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>Task of FuturesOrder</returns>
        public async Task<FuturesOrder> CreateFuturesOrderAsync (string settle, FuturesOrder futuresOrder)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrder> localVarResponse = await CreateFuturesOrderAsyncWithHttpInfo(settle, futuresOrder);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a futures order - Creating futures orders requires &#x60;size&#x60;, which is number of contracts instead of currency amount. You can use &#x60;quanto_multiplier&#x60; in contract detail response to know how much currency 1 size contract represents - Zero-filled order cannot be retrieved 10 minutes after order cancellation. You will get a 404 not found for such orders - Set &#x60;reduce_only&#x60; to &#x60;true&#x60; can keep the position from changing side when reducing position size - In single position mode, to close a position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual position mode, to close one side position, you need to set &#x60;auto_size&#x60; side, &#x60;reduce_only&#x60; to true and &#x60;size&#x60; to 0
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        public async Task<ApiResponse<FuturesOrder>> CreateFuturesOrderAsyncWithHttpInfo (string settle, FuturesOrder futuresOrder)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreateFuturesOrder");

            // verify the required parameter 'futuresOrder' is set
            if (futuresOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrder' when calling FuturesApi->CreateFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = futuresOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<FuturesOrder>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="side">All bids or asks. Both included if not specified (optional)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        public List<FuturesOrder> CancelFuturesOrders (string settle, string contract, string side = default(string))
        {
             ApiResponse<List<FuturesOrder>> localVarResponse = CancelFuturesOrdersWithHttpInfo(settle, contract, side);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="side">All bids or asks. Both included if not specified (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        public ApiResponse<List<FuturesOrder>> CancelFuturesOrdersWithHttpInfo (string settle, string contract, string side = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelFuturesOrders");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->CancelFuturesOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<List<FuturesOrder>>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelFuturesOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="side">All bids or asks. Both included if not specified (optional)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        public async Task<List<FuturesOrder>> CancelFuturesOrdersAsync (string settle, string contract, string side = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesOrder>> localVarResponse = await CancelFuturesOrdersAsyncWithHttpInfo(settle, contract, side);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="side">All bids or asks. Both included if not specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesOrder>>> CancelFuturesOrdersAsyncWithHttpInfo (string settle, string contract, string side = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelFuturesOrders");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->CancelFuturesOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<List<FuturesOrder>>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelFuturesOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a batch of futures orders - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>List&lt;BatchFuturesOrder&gt;</returns>
        public List<BatchFuturesOrder> CreateBatchFuturesOrder (string settle, List<FuturesOrder> futuresOrder)
        {
             ApiResponse<List<BatchFuturesOrder>> localVarResponse = CreateBatchFuturesOrderWithHttpInfo(settle, futuresOrder);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a batch of futures orders - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>ApiResponse of List&lt;BatchFuturesOrder&gt;</returns>
        public ApiResponse<List<BatchFuturesOrder>> CreateBatchFuturesOrderWithHttpInfo (string settle, List<FuturesOrder> futuresOrder)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreateBatchFuturesOrder");

            // verify the required parameter 'futuresOrder' is set
            if (futuresOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrder' when calling FuturesApi->CreateBatchFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = futuresOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<BatchFuturesOrder>>("/futures/{settle}/batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateBatchFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a batch of futures orders - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>Task of List&lt;BatchFuturesOrder&gt;</returns>
        public async Task<List<BatchFuturesOrder>> CreateBatchFuturesOrderAsync (string settle, List<FuturesOrder> futuresOrder)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<BatchFuturesOrder>> localVarResponse = await CreateBatchFuturesOrderAsyncWithHttpInfo(settle, futuresOrder);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a batch of futures orders - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <returns>Task of ApiResponse (List&lt;BatchFuturesOrder&gt;)</returns>
        public async Task<ApiResponse<List<BatchFuturesOrder>>> CreateBatchFuturesOrderAsyncWithHttpInfo (string settle, List<FuturesOrder> futuresOrder)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreateBatchFuturesOrder");

            // verify the required parameter 'futuresOrder' is set
            if (futuresOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrder' when calling FuturesApi->CreateBatchFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = futuresOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<BatchFuturesOrder>>("/futures/{settle}/batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateBatchFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single order Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>FuturesOrder</returns>
        public FuturesOrder GetFuturesOrder (string settle, string orderId)
        {
             ApiResponse<FuturesOrder> localVarResponse = GetFuturesOrderWithHttpInfo(settle, orderId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single order Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        public ApiResponse<FuturesOrder> GetFuturesOrderWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->GetFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single order Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of FuturesOrder</returns>
        public async Task<FuturesOrder> GetFuturesOrderAsync (string settle, string orderId)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrder> localVarResponse = await GetFuturesOrderAsyncWithHttpInfo(settle, orderId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single order Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        public async Task<ApiResponse<FuturesOrder>> GetFuturesOrderAsyncWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->GetFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Amend an order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <returns>FuturesOrder</returns>
        public FuturesOrder AmendFuturesOrder (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment)
        {
             ApiResponse<FuturesOrder> localVarResponse = AmendFuturesOrderWithHttpInfo(settle, orderId, futuresOrderAmendment);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Amend an order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        public ApiResponse<FuturesOrder> AmendFuturesOrderWithHttpInfo (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->AmendFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->AmendFuturesOrder");

            // verify the required parameter 'futuresOrderAmendment' is set
            if (futuresOrderAmendment == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrderAmendment' when calling FuturesApi->AmendFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            localVarRequestOptions.Data = futuresOrderAmendment;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Put<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Amend an order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <returns>Task of FuturesOrder</returns>
        public async Task<FuturesOrder> AmendFuturesOrderAsync (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrder> localVarResponse = await AmendFuturesOrderAsyncWithHttpInfo(settle, orderId, futuresOrderAmendment);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Amend an order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        public async Task<ApiResponse<FuturesOrder>> AmendFuturesOrderAsyncWithHttpInfo (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->AmendFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->AmendFuturesOrder");

            // verify the required parameter 'futuresOrderAmendment' is set
            if (futuresOrderAmendment == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrderAmendment' when calling FuturesApi->AmendFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            localVarRequestOptions.Data = futuresOrderAmendment;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel a single order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>FuturesOrder</returns>
        public FuturesOrder CancelFuturesOrder (string settle, string orderId)
        {
             ApiResponse<FuturesOrder> localVarResponse = CancelFuturesOrderWithHttpInfo(settle, orderId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel a single order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        public ApiResponse<FuturesOrder> CancelFuturesOrderWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->CancelFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel a single order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of FuturesOrder</returns>
        public async Task<FuturesOrder> CancelFuturesOrderAsync (string settle, string orderId)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrder> localVarResponse = await CancelFuturesOrderAsyncWithHttpInfo(settle, orderId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel a single order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        public async Task<ApiResponse<FuturesOrder>> CancelFuturesOrderAsyncWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->CancelFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List personal trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>List&lt;MyFuturesTrade&gt;</returns>
        public List<MyFuturesTrade> GetMyTrades (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
             ApiResponse<List<MyFuturesTrade>> localVarResponse = GetMyTradesWithHttpInfo(settle, contract, order, limit, offset, lastId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List personal trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>ApiResponse of List&lt;MyFuturesTrade&gt;</returns>
        public ApiResponse<List<MyFuturesTrade>> GetMyTradesWithHttpInfo (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetMyTrades");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (order != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "order", order));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<MyFuturesTrade>>("/futures/{settle}/my_trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMyTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List personal trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of List&lt;MyFuturesTrade&gt;</returns>
        public async Task<List<MyFuturesTrade>> GetMyTradesAsync (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<MyFuturesTrade>> localVarResponse = await GetMyTradesAsyncWithHttpInfo(settle, contract, order, limit, offset, lastId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List personal trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;MyFuturesTrade&gt;)</returns>
        public async Task<ApiResponse<List<MyFuturesTrade>>> GetMyTradesAsyncWithHttpInfo (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetMyTrades");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (order != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "order", order));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<MyFuturesTrade>>("/futures/{settle}/my_trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMyTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List personal trading history by time range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;MyFuturesTrade&gt;</returns>
        public List<MyFuturesTrade> GetMyTradesWithTimeRange (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?))
        {
             ApiResponse<List<MyFuturesTrade>> localVarResponse = GetMyTradesWithTimeRangeWithHttpInfo(settle, contract, from, to, limit, offset);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List personal trading history by time range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;MyFuturesTrade&gt;</returns>
        public ApiResponse<List<MyFuturesTrade>> GetMyTradesWithTimeRangeWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetMyTradesWithTimeRange");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<MyFuturesTrade>>("/futures/{settle}/my_trades_timerange", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMyTradesWithTimeRange", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List personal trading history by time range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;MyFuturesTrade&gt;</returns>
        public async Task<List<MyFuturesTrade>> GetMyTradesWithTimeRangeAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<MyFuturesTrade>> localVarResponse = await GetMyTradesWithTimeRangeAsyncWithHttpInfo(settle, contract, from, to, limit, offset);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List personal trading history by time range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;MyFuturesTrade&gt;)</returns>
        public async Task<ApiResponse<List<MyFuturesTrade>>> GetMyTradesWithTimeRangeAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetMyTradesWithTimeRange");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<MyFuturesTrade>>("/futures/{settle}/my_trades_timerange", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMyTradesWithTimeRange", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List position close history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>List&lt;PositionClose&gt;</returns>
        public List<PositionClose> ListPositionClose (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?))
        {
             ApiResponse<List<PositionClose>> localVarResponse = ListPositionCloseWithHttpInfo(settle, contract, limit, offset, from, to);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List position close history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>ApiResponse of List&lt;PositionClose&gt;</returns>
        public ApiResponse<List<PositionClose>> ListPositionCloseWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPositionClose");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<PositionClose>>("/futures/{settle}/position_close", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPositionClose", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List position close history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>Task of List&lt;PositionClose&gt;</returns>
        public async Task<List<PositionClose>> ListPositionCloseAsync (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<PositionClose>> localVarResponse = await ListPositionCloseAsyncWithHttpInfo(settle, contract, limit, offset, from, to);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List position close history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;PositionClose&gt;)</returns>
        public async Task<ApiResponse<List<PositionClose>>> ListPositionCloseAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPositionClose");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<PositionClose>>("/futures/{settle}/position_close", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPositionClose", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List liquidation history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>List&lt;FuturesLiquidate&gt;</returns>
        public List<FuturesLiquidate> ListLiquidates (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
             ApiResponse<List<FuturesLiquidate>> localVarResponse = ListLiquidatesWithHttpInfo(settle, contract, limit, at);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List liquidation history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesLiquidate&gt;</returns>
        public ApiResponse<List<FuturesLiquidate>> ListLiquidatesWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListLiquidates");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (at != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "at", at));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesLiquidate>>("/futures/{settle}/liquidates", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLiquidates", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List liquidation history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesLiquidate&gt;</returns>
        public async Task<List<FuturesLiquidate>> ListLiquidatesAsync (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesLiquidate>> localVarResponse = await ListLiquidatesAsyncWithHttpInfo(settle, contract, limit, at);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List liquidation history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLiquidate&gt;)</returns>
        public async Task<ApiResponse<List<FuturesLiquidate>>> ListLiquidatesAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListLiquidates");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (at != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "at", at));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesLiquidate>>("/futures/{settle}/liquidates", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLiquidates", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Auto-Deleveraging History 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>List&lt;FuturesAutoDeleverage&gt;</returns>
        public List<FuturesAutoDeleverage> ListAutoDeleverages (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
             ApiResponse<List<FuturesAutoDeleverage>> localVarResponse = ListAutoDeleveragesWithHttpInfo(settle, contract, limit, at);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List Auto-Deleveraging History 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesAutoDeleverage&gt;</returns>
        public ApiResponse<List<FuturesAutoDeleverage>> ListAutoDeleveragesWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListAutoDeleverages");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (at != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "at", at));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesAutoDeleverage>>("/futures/{settle}/auto_deleverages", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAutoDeleverages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Auto-Deleveraging History 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesAutoDeleverage&gt;</returns>
        public async Task<List<FuturesAutoDeleverage>> ListAutoDeleveragesAsync (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesAutoDeleverage>> localVarResponse = await ListAutoDeleveragesAsyncWithHttpInfo(settle, contract, limit, at);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List Auto-Deleveraging History 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesAutoDeleverage&gt;)</returns>
        public async Task<ApiResponse<List<FuturesAutoDeleverage>>> ListAutoDeleveragesAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListAutoDeleverages");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (at != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "at", at));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesAutoDeleverage>>("/futures/{settle}/auto_deleverages", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAutoDeleverages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Countdown cancel orders When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>TriggerTime</returns>
        public TriggerTime CountdownCancelAllFutures (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask)
        {
             ApiResponse<TriggerTime> localVarResponse = CountdownCancelAllFuturesWithHttpInfo(settle, countdownCancelAllFuturesTask);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Countdown cancel orders When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>ApiResponse of TriggerTime</returns>
        public ApiResponse<TriggerTime> CountdownCancelAllFuturesWithHttpInfo (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CountdownCancelAllFutures");

            // verify the required parameter 'countdownCancelAllFuturesTask' is set
            if (countdownCancelAllFuturesTask == null)
                throw new ApiException(400, "Missing required parameter 'countdownCancelAllFuturesTask' when calling FuturesApi->CountdownCancelAllFutures");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = countdownCancelAllFuturesTask;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<TriggerTime>("/futures/{settle}/countdown_cancel_all", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CountdownCancelAllFutures", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Countdown cancel orders When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>Task of TriggerTime</returns>
        public async Task<TriggerTime> CountdownCancelAllFuturesAsync (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask)
        {
             Io.Gate.GateApi.Client.ApiResponse<TriggerTime> localVarResponse = await CountdownCancelAllFuturesAsyncWithHttpInfo(settle, countdownCancelAllFuturesTask);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Countdown cancel orders When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>Task of ApiResponse (TriggerTime)</returns>
        public async Task<ApiResponse<TriggerTime>> CountdownCancelAllFuturesAsyncWithHttpInfo (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CountdownCancelAllFutures");

            // verify the required parameter 'countdownCancelAllFuturesTask' is set
            if (countdownCancelAllFuturesTask == null)
                throw new ApiException(400, "Missing required parameter 'countdownCancelAllFuturesTask' when calling FuturesApi->CountdownCancelAllFutures");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = countdownCancelAllFuturesTask;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<TriggerTime>("/futures/{settle}/countdown_cancel_all", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CountdownCancelAllFutures", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all auto orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public List<FuturesPriceTriggeredOrder> ListPriceTriggeredOrders (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
             ApiResponse<List<FuturesPriceTriggeredOrder>> localVarResponse = ListPriceTriggeredOrdersWithHttpInfo(settle, status, contract, limit, offset);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List all auto orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public ApiResponse<List<FuturesPriceTriggeredOrder>> ListPriceTriggeredOrdersWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPriceTriggeredOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling FuturesApi->ListPriceTriggeredOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesPriceTriggeredOrder>>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPriceTriggeredOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all auto orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public async Task<List<FuturesPriceTriggeredOrder>> ListPriceTriggeredOrdersAsync (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesPriceTriggeredOrder>> localVarResponse = await ListPriceTriggeredOrdersAsyncWithHttpInfo(settle, status, contract, limit, offset);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List all auto orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPriceTriggeredOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesPriceTriggeredOrder>>> ListPriceTriggeredOrdersAsyncWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPriceTriggeredOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling FuturesApi->ListPriceTriggeredOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesPriceTriggeredOrder>>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPriceTriggeredOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>TriggerOrderResponse</returns>
        public TriggerOrderResponse CreatePriceTriggeredOrder (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder)
        {
             ApiResponse<TriggerOrderResponse> localVarResponse = CreatePriceTriggeredOrderWithHttpInfo(settle, futuresPriceTriggeredOrder);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>ApiResponse of TriggerOrderResponse</returns>
        public ApiResponse<TriggerOrderResponse> CreatePriceTriggeredOrderWithHttpInfo (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreatePriceTriggeredOrder");

            // verify the required parameter 'futuresPriceTriggeredOrder' is set
            if (futuresPriceTriggeredOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresPriceTriggeredOrder' when calling FuturesApi->CreatePriceTriggeredOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = futuresPriceTriggeredOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<TriggerOrderResponse>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreatePriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>Task of TriggerOrderResponse</returns>
        public async Task<TriggerOrderResponse> CreatePriceTriggeredOrderAsync (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder)
        {
             Io.Gate.GateApi.Client.ApiResponse<TriggerOrderResponse> localVarResponse = await CreatePriceTriggeredOrderAsyncWithHttpInfo(settle, futuresPriceTriggeredOrder);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>Task of ApiResponse (TriggerOrderResponse)</returns>
        public async Task<ApiResponse<TriggerOrderResponse>> CreatePriceTriggeredOrderAsyncWithHttpInfo (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreatePriceTriggeredOrder");

            // verify the required parameter 'futuresPriceTriggeredOrder' is set
            if (futuresPriceTriggeredOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresPriceTriggeredOrder' when calling FuturesApi->CreatePriceTriggeredOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = futuresPriceTriggeredOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<TriggerOrderResponse>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreatePriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all open orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public List<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderList (string settle, string contract)
        {
             ApiResponse<List<FuturesPriceTriggeredOrder>> localVarResponse = CancelPriceTriggeredOrderListWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel all open orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public ApiResponse<List<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderListWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelPriceTriggeredOrderList");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->CancelPriceTriggeredOrderList");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<List<FuturesPriceTriggeredOrder>>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelPriceTriggeredOrderList", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all open orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public async Task<List<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderListAsync (string settle, string contract)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesPriceTriggeredOrder>> localVarResponse = await CancelPriceTriggeredOrderListAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel all open orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPriceTriggeredOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesPriceTriggeredOrder>>> CancelPriceTriggeredOrderListAsyncWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelPriceTriggeredOrderList");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->CancelPriceTriggeredOrderList");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<List<FuturesPriceTriggeredOrder>>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelPriceTriggeredOrderList", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>FuturesPriceTriggeredOrder</returns>
        public FuturesPriceTriggeredOrder GetPriceTriggeredOrder (string settle, string orderId)
        {
             ApiResponse<FuturesPriceTriggeredOrder> localVarResponse = GetPriceTriggeredOrderWithHttpInfo(settle, orderId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>ApiResponse of FuturesPriceTriggeredOrder</returns>
        public ApiResponse<FuturesPriceTriggeredOrder> GetPriceTriggeredOrderWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetPriceTriggeredOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->GetPriceTriggeredOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesPriceTriggeredOrder>("/futures/{settle}/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of FuturesPriceTriggeredOrder</returns>
        public async Task<FuturesPriceTriggeredOrder> GetPriceTriggeredOrderAsync (string settle, string orderId)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesPriceTriggeredOrder> localVarResponse = await GetPriceTriggeredOrderAsyncWithHttpInfo(settle, orderId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of ApiResponse (FuturesPriceTriggeredOrder)</returns>
        public async Task<ApiResponse<FuturesPriceTriggeredOrder>> GetPriceTriggeredOrderAsyncWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetPriceTriggeredOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->GetPriceTriggeredOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesPriceTriggeredOrder>("/futures/{settle}/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// cancel a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>FuturesPriceTriggeredOrder</returns>
        public FuturesPriceTriggeredOrder CancelPriceTriggeredOrder (string settle, string orderId)
        {
             ApiResponse<FuturesPriceTriggeredOrder> localVarResponse = CancelPriceTriggeredOrderWithHttpInfo(settle, orderId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// cancel a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>ApiResponse of FuturesPriceTriggeredOrder</returns>
        public ApiResponse<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelPriceTriggeredOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->CancelPriceTriggeredOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<FuturesPriceTriggeredOrder>("/futures/{settle}/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// cancel a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of FuturesPriceTriggeredOrder</returns>
        public async Task<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderAsync (string settle, string orderId)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesPriceTriggeredOrder> localVarResponse = await CancelPriceTriggeredOrderAsyncWithHttpInfo(settle, orderId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// cancel a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of ApiResponse (FuturesPriceTriggeredOrder)</returns>
        public async Task<ApiResponse<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderAsyncWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelPriceTriggeredOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->CancelPriceTriggeredOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<FuturesPriceTriggeredOrder>("/futures/{settle}/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
