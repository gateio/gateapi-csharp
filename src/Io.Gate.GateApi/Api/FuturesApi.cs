/*
 * Gate API v4
 *
 * Welcome to Gate.io API  APIv4 provides spot, margin and futures trading operations. There are public APIs to retrieve the real-time market statistics, and private APIs which needs authentication to trade on user's behalf.
 *
 * Contact: support@mail.gate.io
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using System.Threading.Tasks;
using Io.Gate.GateApi.Client;
using Io.Gate.GateApi.Model;

namespace Io.Gate.GateApi.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFuturesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// List all futures contracts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;Contract&gt;</returns>
        List<Contract> ListFuturesContracts (string settle, int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List all futures contracts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;Contract&gt;</returns>
        ApiResponse<List<Contract>> ListFuturesContractsWithHttpInfo (string settle, int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Get a single contract
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Contract</returns>
        Contract GetFuturesContract (string settle, string contract);

        /// <summary>
        /// Get a single contract
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of Contract</returns>
        ApiResponse<Contract> GetFuturesContractWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Futures order book
        /// </summary>
        /// <remarks>
        /// Bids will be sorted by price from high to low, while asks sorted reversely
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>FuturesOrderBook</returns>
        FuturesOrderBook ListFuturesOrderBook (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));

        /// <summary>
        /// Futures order book
        /// </summary>
        /// <remarks>
        /// Bids will be sorted by price from high to low, while asks sorted reversely
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>ApiResponse of FuturesOrderBook</returns>
        ApiResponse<FuturesOrderBook> ListFuturesOrderBookWithHttpInfo (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));
        /// <summary>
        /// Futures trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>List&lt;FuturesTrade&gt;</returns>
        List<FuturesTrade> ListFuturesTrades (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// Futures trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesTrade&gt;</returns>
        ApiResponse<List<FuturesTrade>> ListFuturesTradesWithHttpInfo (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// Get futures candlesticks
        /// </summary>
        /// <remarks>
        /// Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0.  Note that 30d means 1 natual month, not 30 days (optional, default to &quot;5m&quot;)</param>
        /// <returns>List&lt;FuturesCandlestick&gt;</returns>
        List<FuturesCandlestick> ListFuturesCandlesticks (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));

        /// <summary>
        /// Get futures candlesticks
        /// </summary>
        /// <remarks>
        /// Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0.  Note that 30d means 1 natual month, not 30 days (optional, default to &quot;5m&quot;)</param>
        /// <returns>ApiResponse of List&lt;FuturesCandlestick&gt;</returns>
        ApiResponse<List<FuturesCandlestick>> ListFuturesCandlesticksWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));
        /// <summary>
        /// Premium Index K-Line
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to &quot;5m&quot;)</param>
        /// <returns>List&lt;FuturesPremiumIndex&gt;</returns>
        List<FuturesPremiumIndex> ListFuturesPremiumIndex (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));

        /// <summary>
        /// Premium Index K-Line
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to &quot;5m&quot;)</param>
        /// <returns>ApiResponse of List&lt;FuturesPremiumIndex&gt;</returns>
        ApiResponse<List<FuturesPremiumIndex>> ListFuturesPremiumIndexWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));
        /// <summary>
        /// List futures tickers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>List&lt;FuturesTicker&gt;</returns>
        List<FuturesTicker> ListFuturesTickers (string settle, string contract = default(string));

        /// <summary>
        /// List futures tickers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesTicker&gt;</returns>
        ApiResponse<List<FuturesTicker>> ListFuturesTickersWithHttpInfo (string settle, string contract = default(string));
        /// <summary>
        /// Funding rate history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>List&lt;FundingRateRecord&gt;</returns>
        List<FundingRateRecord> ListFuturesFundingRateHistory (string settle, string contract, int? limit = default(int?), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// Funding rate history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>ApiResponse of List&lt;FundingRateRecord&gt;</returns>
        ApiResponse<List<FundingRateRecord>> ListFuturesFundingRateHistoryWithHttpInfo (string settle, string contract, int? limit = default(int?), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// Futures insurance balance history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;InsuranceRecord&gt;</returns>
        List<InsuranceRecord> ListFuturesInsuranceLedger (string settle, int? limit = default(int?));

        /// <summary>
        /// Futures insurance balance history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;InsuranceRecord&gt;</returns>
        ApiResponse<List<InsuranceRecord>> ListFuturesInsuranceLedgerWithHttpInfo (string settle, int? limit = default(int?));
        /// <summary>
        /// Futures stats
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to &quot;5m&quot;)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>List&lt;ContractStat&gt;</returns>
        List<ContractStat> ListContractStats (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?));

        /// <summary>
        /// Futures stats
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to &quot;5m&quot;)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>ApiResponse of List&lt;ContractStat&gt;</returns>
        ApiResponse<List<ContractStat>> ListContractStatsWithHttpInfo (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?));
        /// <summary>
        /// Get index constituents
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>FuturesIndexConstituents</returns>
        FuturesIndexConstituents GetIndexConstituents (string settle, string index);

        /// <summary>
        /// Get index constituents
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>ApiResponse of FuturesIndexConstituents</returns>
        ApiResponse<FuturesIndexConstituents> GetIndexConstituentsWithHttpInfo (string settle, string index);
        /// <summary>
        /// Retrieve liquidation history
        /// </summary>
        /// <remarks>
        /// Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;FuturesLiqOrder&gt;</returns>
        List<FuturesLiqOrder> ListLiquidatedOrders (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?));

        /// <summary>
        /// Retrieve liquidation history
        /// </summary>
        /// <remarks>
        /// Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;FuturesLiqOrder&gt;</returns>
        ApiResponse<List<FuturesLiqOrder>> ListLiquidatedOrdersWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?));
        /// <summary>
        /// List risk limit tiers
        /// </summary>
        /// <remarks>
        /// When the &#39;contract&#39; parameter is not passed, the default is to query the risk limits for the top 100 markets.&#39;Limit&#39; and &#39;offset&#39; correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the &#39;contract&#39; parameter is empty.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;FuturesLimitRiskTiers&gt;</returns>
        List<FuturesLimitRiskTiers> ListFuturesRiskLimitTiers (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List risk limit tiers
        /// </summary>
        /// <remarks>
        /// When the &#39;contract&#39; parameter is not passed, the default is to query the risk limits for the top 100 markets.&#39;Limit&#39; and &#39;offset&#39; correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the &#39;contract&#39; parameter is empty.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesLimitRiskTiers&gt;</returns>
        ApiResponse<List<FuturesLimitRiskTiers>> ListFuturesRiskLimitTiersWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Query futures account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>FuturesAccount</returns>
        FuturesAccount ListFuturesAccounts (string settle);

        /// <summary>
        /// Query futures account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>ApiResponse of FuturesAccount</returns>
        ApiResponse<FuturesAccount> ListFuturesAccountsWithHttpInfo (string settle);
        /// <summary>
        /// Query account book
        /// </summary>
        /// <remarks>
        /// If the &#x60;contract&#x60; field is provided, it can only filter records that include this field after 2023-10-30.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)</param>
        /// <returns>List&lt;FuturesAccountBook&gt;</returns>
        List<FuturesAccountBook> ListFuturesAccountBook (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string));

        /// <summary>
        /// Query account book
        /// </summary>
        /// <remarks>
        /// If the &#x60;contract&#x60; field is provided, it can only filter records that include this field after 2023-10-30.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesAccountBook&gt;</returns>
        ApiResponse<List<FuturesAccountBook>> ListFuturesAccountBookWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string));
        /// <summary>
        /// List all positions of a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="holding">Return only real positions - true, return all - false. (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> ListPositions (string settle, bool? holding = default(bool?), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List all positions of a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="holding">Return only real positions - true, return all - false. (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> ListPositionsWithHttpInfo (string settle, bool? holding = default(bool?), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Get single position
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Position</returns>
        Position GetPosition (string settle, string contract);

        /// <summary>
        /// Get single position
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of Position</returns>
        ApiResponse<Position> GetPositionWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Update position margin
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Position</returns>
        Position UpdatePositionMargin (string settle, string contract, string change);

        /// <summary>
        /// Update position margin
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>ApiResponse of Position</returns>
        ApiResponse<Position> UpdatePositionMarginWithHttpInfo (string settle, string contract, string change);
        /// <summary>
        /// Update position leverage
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Position</returns>
        Position UpdatePositionLeverage (string settle, string contract, string leverage, string crossLeverageLimit = default(string));

        /// <summary>
        /// Update position leverage
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>ApiResponse of Position</returns>
        ApiResponse<Position> UpdatePositionLeverageWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string));
        /// <summary>
        /// Switch to the full position-by-store mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="inlineObject"></param>
        /// <returns>Position</returns>
        Position UpdatePositionCrossMode (string settle, InlineObject inlineObject);

        /// <summary>
        /// Switch to the full position-by-store mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="inlineObject"></param>
        /// <returns>ApiResponse of Position</returns>
        ApiResponse<Position> UpdatePositionCrossModeWithHttpInfo (string settle, InlineObject inlineObject);
        /// <summary>
        /// Update position risk limit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Position</returns>
        Position UpdatePositionRiskLimit (string settle, string contract, string riskLimit);

        /// <summary>
        /// Update position risk limit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>ApiResponse of Position</returns>
        ApiResponse<Position> UpdatePositionRiskLimitWithHttpInfo (string settle, string contract, string riskLimit);
        /// <summary>
        /// Enable or disable dual mode
        /// </summary>
        /// <remarks>
        /// Before setting dual mode, make sure all positions are closed and no orders are open
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>FuturesAccount</returns>
        FuturesAccount SetDualMode (string settle, bool dualMode);

        /// <summary>
        /// Enable or disable dual mode
        /// </summary>
        /// <remarks>
        /// Before setting dual mode, make sure all positions are closed and no orders are open
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>ApiResponse of FuturesAccount</returns>
        ApiResponse<FuturesAccount> SetDualModeWithHttpInfo (string settle, bool dualMode);
        /// <summary>
        /// Retrieve position detail in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> GetDualModePosition (string settle, string contract);

        /// <summary>
        /// Retrieve position detail in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> GetDualModePositionWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Update position margin in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> UpdateDualModePositionMargin (string settle, string contract, string change, string dualSide);

        /// <summary>
        /// Update position margin in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> UpdateDualModePositionMarginWithHttpInfo (string settle, string contract, string change, string dualSide);
        /// <summary>
        /// Update position leverage in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> UpdateDualModePositionLeverage (string settle, string contract, string leverage, string crossLeverageLimit = default(string));

        /// <summary>
        /// Update position leverage in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> UpdateDualModePositionLeverageWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string));
        /// <summary>
        /// Update position risk limit in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>List&lt;Position&gt;</returns>
        List<Position> UpdateDualModePositionRiskLimit (string settle, string contract, string riskLimit);

        /// <summary>
        /// Update position risk limit in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        ApiResponse<List<Position>> UpdateDualModePositionRiskLimitWithHttpInfo (string settle, string contract, string riskLimit);
        /// <summary>
        /// List futures orders
        /// </summary>
        /// <remarks>
        /// - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/orders_timerange&#x60;.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        List<FuturesOrder> ListFuturesOrders (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));

        /// <summary>
        /// List futures orders
        /// </summary>
        /// <remarks>
        /// - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/orders_timerange&#x60;.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        ApiResponse<List<FuturesOrder>> ListFuturesOrdersWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));
        /// <summary>
        /// Create a futures order
        /// </summary>
        /// <remarks>
        /// - When placing an order, the number of contracts is specified &#x60;size&#x60;, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface &#x60;quanto_multiplier&#x60; - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting &#x60;reduce_only&#x60; to &#x60;true&#x60; can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual warehouse mode,   - Reduce position: reduce_only&#x3D;true, size is a positive number that indicates short position, negative number that indicates long position  - Add position: reduce_only&#x3D;false, size is a positive number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size&#x3D;0, set the direction of closing position according to auto_size, and set &#x60;reduce_only&#x60; to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set &#x60;stp_act&#x60; to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter &#x60;stp_act&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>FuturesOrder</returns>
        FuturesOrder CreateFuturesOrder (string settle, FuturesOrder futuresOrder, string xGateExptime = default(string));

        /// <summary>
        /// Create a futures order
        /// </summary>
        /// <remarks>
        /// - When placing an order, the number of contracts is specified &#x60;size&#x60;, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface &#x60;quanto_multiplier&#x60; - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting &#x60;reduce_only&#x60; to &#x60;true&#x60; can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual warehouse mode,   - Reduce position: reduce_only&#x3D;true, size is a positive number that indicates short position, negative number that indicates long position  - Add position: reduce_only&#x3D;false, size is a positive number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size&#x3D;0, set the direction of closing position according to auto_size, and set &#x60;reduce_only&#x60; to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set &#x60;stp_act&#x60; to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter &#x60;stp_act&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        ApiResponse<FuturesOrder> CreateFuturesOrderWithHttpInfo (string settle, FuturesOrder futuresOrder, string xGateExptime = default(string));
        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <param name="side">Specify all buy orders or all sell orders, if not specify them, both are included. Revoke all buy orders and revoke all sell orders and make ask (optional)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        List<FuturesOrder> CancelFuturesOrders (string settle, string contract, string xGateExptime = default(string), string side = default(string));

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <param name="side">Specify all buy orders or all sell orders, if not specify them, both are included. Revoke all buy orders and revoke all sell orders and make ask (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        ApiResponse<List<FuturesOrder>> CancelFuturesOrdersWithHttpInfo (string settle, string contract, string xGateExptime = default(string), string side = default(string));
        /// <summary>
        /// List Futures Orders By Time Range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        List<FuturesOrder> GetOrdersWithTimeRange (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List Futures Orders By Time Range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        ApiResponse<List<FuturesOrder>> GetOrdersWithTimeRangeWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Create a batch of futures orders
        /// </summary>
        /// <remarks>
        /// - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;BatchFuturesOrder&gt;</returns>
        List<BatchFuturesOrder> CreateBatchFuturesOrder (string settle, List<FuturesOrder> futuresOrder, string xGateExptime = default(string));

        /// <summary>
        /// Create a batch of futures orders
        /// </summary>
        /// <remarks>
        /// - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;BatchFuturesOrder&gt;</returns>
        ApiResponse<List<BatchFuturesOrder>> CreateBatchFuturesOrderWithHttpInfo (string settle, List<FuturesOrder> futuresOrder, string xGateExptime = default(string));
        /// <summary>
        /// Get a single order
        /// </summary>
        /// <remarks>
        /// - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>FuturesOrder</returns>
        FuturesOrder GetFuturesOrder (string settle, string orderId);

        /// <summary>
        /// Get a single order
        /// </summary>
        /// <remarks>
        /// - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        ApiResponse<FuturesOrder> GetFuturesOrderWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// Amend an order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>FuturesOrder</returns>
        FuturesOrder AmendFuturesOrder (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment, string xGateExptime = default(string));

        /// <summary>
        /// Amend an order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        ApiResponse<FuturesOrder> AmendFuturesOrderWithHttpInfo (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment, string xGateExptime = default(string));
        /// <summary>
        /// Cancel a single order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>FuturesOrder</returns>
        FuturesOrder CancelFuturesOrder (string settle, string orderId, string xGateExptime = default(string));

        /// <summary>
        /// Cancel a single order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        ApiResponse<FuturesOrder> CancelFuturesOrderWithHttpInfo (string settle, string orderId, string xGateExptime = default(string));
        /// <summary>
        /// List personal trading history
        /// </summary>
        /// <remarks>
        /// By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/my_trades_timerange&#x60;.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)</param>
        /// <returns>List&lt;MyFuturesTrade&gt;</returns>
        List<MyFuturesTrade> GetMyTrades (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));

        /// <summary>
        /// List personal trading history
        /// </summary>
        /// <remarks>
        /// By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/my_trades_timerange&#x60;.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)</param>
        /// <returns>ApiResponse of List&lt;MyFuturesTrade&gt;</returns>
        ApiResponse<List<MyFuturesTrade>> GetMyTradesWithHttpInfo (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));
        /// <summary>
        /// List personal trading history by time range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="role">Query role, maker or taker. (optional)</param>
        /// <returns>List&lt;MyFuturesTradeTimeRange&gt;</returns>
        List<MyFuturesTradeTimeRange> GetMyTradesWithTimeRange (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?), string role = default(string));

        /// <summary>
        /// List personal trading history by time range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="role">Query role, maker or taker. (optional)</param>
        /// <returns>ApiResponse of List&lt;MyFuturesTradeTimeRange&gt;</returns>
        ApiResponse<List<MyFuturesTradeTimeRange>> GetMyTradesWithTimeRangeWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?), string role = default(string));
        /// <summary>
        /// List position close history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="side">Query side.  long or shot (optional)</param>
        /// <param name="pnl">Query profit or loss (optional)</param>
        /// <returns>List&lt;PositionClose&gt;</returns>
        List<PositionClose> ListPositionClose (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string side = default(string), string pnl = default(string));

        /// <summary>
        /// List position close history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="side">Query side.  long or shot (optional)</param>
        /// <param name="pnl">Query profit or loss (optional)</param>
        /// <returns>ApiResponse of List&lt;PositionClose&gt;</returns>
        ApiResponse<List<PositionClose>> ListPositionCloseWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string side = default(string), string pnl = default(string));
        /// <summary>
        /// List liquidation history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>List&lt;FuturesLiquidate&gt;</returns>
        List<FuturesLiquidate> ListLiquidates (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));

        /// <summary>
        /// List liquidation history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesLiquidate&gt;</returns>
        ApiResponse<List<FuturesLiquidate>> ListLiquidatesWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));
        /// <summary>
        /// List Auto-Deleveraging History
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>List&lt;FuturesAutoDeleverage&gt;</returns>
        List<FuturesAutoDeleverage> ListAutoDeleverages (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));

        /// <summary>
        /// List Auto-Deleveraging History
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesAutoDeleverage&gt;</returns>
        ApiResponse<List<FuturesAutoDeleverage>> ListAutoDeleveragesWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));
        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>TriggerTime</returns>
        TriggerTime CountdownCancelAllFutures (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask);

        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>ApiResponse of TriggerTime</returns>
        ApiResponse<TriggerTime> CountdownCancelAllFuturesWithHttpInfo (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask);
        /// <summary>
        /// Query user trading fee rates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Dictionary&lt;string, FuturesFee&gt;</returns>
        Dictionary<string, FuturesFee> GetFuturesFee (string settle, string contract = default(string));

        /// <summary>
        /// Query user trading fee rates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, FuturesFee&gt;</returns>
        ApiResponse<Dictionary<string, FuturesFee>> GetFuturesFeeWithHttpInfo (string settle, string contract = default(string));
        /// <summary>
        /// Cancel a batch of orders with an ID list
        /// </summary>
        /// <remarks>
        /// Multiple distinct order ID list can be specified。Each request can cancel a maximum of 20 records.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="requestBody"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;FutureCancelOrderResult&gt;</returns>
        List<FutureCancelOrderResult> CancelBatchFutureOrders (string settle, List<string> requestBody, string xGateExptime = default(string));

        /// <summary>
        /// Cancel a batch of orders with an ID list
        /// </summary>
        /// <remarks>
        /// Multiple distinct order ID list can be specified。Each request can cancel a maximum of 20 records.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="requestBody"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;FutureCancelOrderResult&gt;</returns>
        ApiResponse<List<FutureCancelOrderResult>> CancelBatchFutureOrdersWithHttpInfo (string settle, List<string> requestBody, string xGateExptime = default(string));
        /// <summary>
        /// Batch modify orders with specified IDs
        /// </summary>
        /// <remarks>
        /// You can specify multiple different order IDs. You can only modify up to 10 orders in one request.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="batchAmendOrderReq"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;BatchFuturesOrder&gt;</returns>
        List<BatchFuturesOrder> AmendBatchFutureOrders (string settle, List<BatchAmendOrderReq> batchAmendOrderReq, string xGateExptime = default(string));

        /// <summary>
        /// Batch modify orders with specified IDs
        /// </summary>
        /// <remarks>
        /// You can specify multiple different order IDs. You can only modify up to 10 orders in one request.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="batchAmendOrderReq"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;BatchFuturesOrder&gt;</returns>
        ApiResponse<List<BatchFuturesOrder>> AmendBatchFutureOrdersWithHttpInfo (string settle, List<BatchAmendOrderReq> batchAmendOrderReq, string xGateExptime = default(string));
        /// <summary>
        /// List All Price-triggered Orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        List<FuturesPriceTriggeredOrder> ListPriceTriggeredOrders (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List All Price-triggered Orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        ApiResponse<List<FuturesPriceTriggeredOrder>> ListPriceTriggeredOrdersWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Create a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>TriggerOrderResponse</returns>
        TriggerOrderResponse CreatePriceTriggeredOrder (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder);

        /// <summary>
        /// Create a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>ApiResponse of TriggerOrderResponse</returns>
        ApiResponse<TriggerOrderResponse> CreatePriceTriggeredOrderWithHttpInfo (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder);
        /// <summary>
        /// Cancel All Price-triggered Orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        List<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderList (string settle, string contract = default(string));

        /// <summary>
        /// Cancel All Price-triggered Orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        ApiResponse<List<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderListWithHttpInfo (string settle, string contract = default(string));
        /// <summary>
        /// Get a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>FuturesPriceTriggeredOrder</returns>
        FuturesPriceTriggeredOrder GetPriceTriggeredOrder (string settle, string orderId);

        /// <summary>
        /// Get a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>ApiResponse of FuturesPriceTriggeredOrder</returns>
        ApiResponse<FuturesPriceTriggeredOrder> GetPriceTriggeredOrderWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// cancel a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>FuturesPriceTriggeredOrder</returns>
        FuturesPriceTriggeredOrder CancelPriceTriggeredOrder (string settle, string orderId);

        /// <summary>
        /// cancel a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>ApiResponse of FuturesPriceTriggeredOrder</returns>
        ApiResponse<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderWithHttpInfo (string settle, string orderId);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFuturesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// List all futures contracts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;Contract&gt;</returns>
        Task<List<Contract>> ListFuturesContractsAsync (string settle, int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List all futures contracts
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;Contract&gt;)</returns>
        Task<ApiResponse<List<Contract>>> ListFuturesContractsAsyncWithHttpInfo (string settle, int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Get a single contract
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of Contract</returns>
        Task<Contract> GetFuturesContractAsync (string settle, string contract);

        /// <summary>
        /// Get a single contract
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (Contract)</returns>
        Task<ApiResponse<Contract>> GetFuturesContractAsyncWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Futures order book
        /// </summary>
        /// <remarks>
        /// Bids will be sorted by price from high to low, while asks sorted reversely
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>Task of FuturesOrderBook</returns>
        Task<FuturesOrderBook> ListFuturesOrderBookAsync (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));

        /// <summary>
        /// Futures order book
        /// </summary>
        /// <remarks>
        /// Bids will be sorted by price from high to low, while asks sorted reversely
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>Task of ApiResponse (FuturesOrderBook)</returns>
        Task<ApiResponse<FuturesOrderBook>> ListFuturesOrderBookAsyncWithHttpInfo (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?));
        /// <summary>
        /// Futures trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>Task of List&lt;FuturesTrade&gt;</returns>
        Task<List<FuturesTrade>> ListFuturesTradesAsync (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// Futures trading history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesTrade&gt;)</returns>
        Task<ApiResponse<List<FuturesTrade>>> ListFuturesTradesAsyncWithHttpInfo (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// Get futures candlesticks
        /// </summary>
        /// <remarks>
        /// Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0.  Note that 30d means 1 natual month, not 30 days (optional, default to &quot;5m&quot;)</param>
        /// <returns>Task of List&lt;FuturesCandlestick&gt;</returns>
        Task<List<FuturesCandlestick>> ListFuturesCandlesticksAsync (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));

        /// <summary>
        /// Get futures candlesticks
        /// </summary>
        /// <remarks>
        /// Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0.  Note that 30d means 1 natual month, not 30 days (optional, default to &quot;5m&quot;)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesCandlestick&gt;)</returns>
        Task<ApiResponse<List<FuturesCandlestick>>> ListFuturesCandlesticksAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));
        /// <summary>
        /// Premium Index K-Line
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to &quot;5m&quot;)</param>
        /// <returns>Task of List&lt;FuturesPremiumIndex&gt;</returns>
        Task<List<FuturesPremiumIndex>> ListFuturesPremiumIndexAsync (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));

        /// <summary>
        /// Premium Index K-Line
        /// </summary>
        /// <remarks>
        /// Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to &quot;5m&quot;)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPremiumIndex&gt;)</returns>
        Task<ApiResponse<List<FuturesPremiumIndex>>> ListFuturesPremiumIndexAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string));
        /// <summary>
        /// List futures tickers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of List&lt;FuturesTicker&gt;</returns>
        Task<List<FuturesTicker>> ListFuturesTickersAsync (string settle, string contract = default(string));

        /// <summary>
        /// List futures tickers
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesTicker&gt;)</returns>
        Task<ApiResponse<List<FuturesTicker>>> ListFuturesTickersAsyncWithHttpInfo (string settle, string contract = default(string));
        /// <summary>
        /// Funding rate history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>Task of List&lt;FundingRateRecord&gt;</returns>
        Task<List<FundingRateRecord>> ListFuturesFundingRateHistoryAsync (string settle, string contract, int? limit = default(int?), long? from = default(long?), long? to = default(long?));

        /// <summary>
        /// Funding rate history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FundingRateRecord&gt;)</returns>
        Task<ApiResponse<List<FundingRateRecord>>> ListFuturesFundingRateHistoryAsyncWithHttpInfo (string settle, string contract, int? limit = default(int?), long? from = default(long?), long? to = default(long?));
        /// <summary>
        /// Futures insurance balance history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;InsuranceRecord&gt;</returns>
        Task<List<InsuranceRecord>> ListFuturesInsuranceLedgerAsync (string settle, int? limit = default(int?));

        /// <summary>
        /// Futures insurance balance history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;InsuranceRecord&gt;)</returns>
        Task<ApiResponse<List<InsuranceRecord>>> ListFuturesInsuranceLedgerAsyncWithHttpInfo (string settle, int? limit = default(int?));
        /// <summary>
        /// Futures stats
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to &quot;5m&quot;)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>Task of List&lt;ContractStat&gt;</returns>
        Task<List<ContractStat>> ListContractStatsAsync (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?));

        /// <summary>
        /// Futures stats
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to &quot;5m&quot;)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>Task of ApiResponse (List&lt;ContractStat&gt;)</returns>
        Task<ApiResponse<List<ContractStat>>> ListContractStatsAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?));
        /// <summary>
        /// Get index constituents
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>Task of FuturesIndexConstituents</returns>
        Task<FuturesIndexConstituents> GetIndexConstituentsAsync (string settle, string index);

        /// <summary>
        /// Get index constituents
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>Task of ApiResponse (FuturesIndexConstituents)</returns>
        Task<ApiResponse<FuturesIndexConstituents>> GetIndexConstituentsAsyncWithHttpInfo (string settle, string index);
        /// <summary>
        /// Retrieve liquidation history
        /// </summary>
        /// <remarks>
        /// Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;FuturesLiqOrder&gt;</returns>
        Task<List<FuturesLiqOrder>> ListLiquidatedOrdersAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?));

        /// <summary>
        /// Retrieve liquidation history
        /// </summary>
        /// <remarks>
        /// Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLiqOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesLiqOrder>>> ListLiquidatedOrdersAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?));
        /// <summary>
        /// List risk limit tiers
        /// </summary>
        /// <remarks>
        /// When the &#39;contract&#39; parameter is not passed, the default is to query the risk limits for the top 100 markets.&#39;Limit&#39; and &#39;offset&#39; correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the &#39;contract&#39; parameter is empty.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesLimitRiskTiers&gt;</returns>
        Task<List<FuturesLimitRiskTiers>> ListFuturesRiskLimitTiersAsync (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List risk limit tiers
        /// </summary>
        /// <remarks>
        /// When the &#39;contract&#39; parameter is not passed, the default is to query the risk limits for the top 100 markets.&#39;Limit&#39; and &#39;offset&#39; correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the &#39;contract&#39; parameter is empty.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLimitRiskTiers&gt;)</returns>
        Task<ApiResponse<List<FuturesLimitRiskTiers>>> ListFuturesRiskLimitTiersAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Query futures account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of FuturesAccount</returns>
        Task<FuturesAccount> ListFuturesAccountsAsync (string settle);

        /// <summary>
        /// Query futures account
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of ApiResponse (FuturesAccount)</returns>
        Task<ApiResponse<FuturesAccount>> ListFuturesAccountsAsyncWithHttpInfo (string settle);
        /// <summary>
        /// Query account book
        /// </summary>
        /// <remarks>
        /// If the &#x60;contract&#x60; field is provided, it can only filter records that include this field after 2023-10-30.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)</param>
        /// <returns>Task of List&lt;FuturesAccountBook&gt;</returns>
        Task<List<FuturesAccountBook>> ListFuturesAccountBookAsync (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string));

        /// <summary>
        /// Query account book
        /// </summary>
        /// <remarks>
        /// If the &#x60;contract&#x60; field is provided, it can only filter records that include this field after 2023-10-30.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesAccountBook&gt;)</returns>
        Task<ApiResponse<List<FuturesAccountBook>>> ListFuturesAccountBookAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string));
        /// <summary>
        /// List all positions of a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="holding">Return only real positions - true, return all - false. (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> ListPositionsAsync (string settle, bool? holding = default(bool?), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List all positions of a user
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="holding">Return only real positions - true, return all - false. (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> ListPositionsAsyncWithHttpInfo (string settle, bool? holding = default(bool?), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Get single position
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of Position</returns>
        Task<Position> GetPositionAsync (string settle, string contract);

        /// <summary>
        /// Get single position
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        Task<ApiResponse<Position>> GetPositionAsyncWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Update position margin
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Task of Position</returns>
        Task<Position> UpdatePositionMarginAsync (string settle, string contract, string change);

        /// <summary>
        /// Update position margin
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        Task<ApiResponse<Position>> UpdatePositionMarginAsyncWithHttpInfo (string settle, string contract, string change);
        /// <summary>
        /// Update position leverage
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of Position</returns>
        Task<Position> UpdatePositionLeverageAsync (string settle, string contract, string leverage, string crossLeverageLimit = default(string));

        /// <summary>
        /// Update position leverage
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        Task<ApiResponse<Position>> UpdatePositionLeverageAsyncWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string));
        /// <summary>
        /// Switch to the full position-by-store mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="inlineObject"></param>
        /// <returns>Task of Position</returns>
        Task<Position> UpdatePositionCrossModeAsync (string settle, InlineObject inlineObject);

        /// <summary>
        /// Switch to the full position-by-store mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="inlineObject"></param>
        /// <returns>Task of ApiResponse (Position)</returns>
        Task<ApiResponse<Position>> UpdatePositionCrossModeAsyncWithHttpInfo (string settle, InlineObject inlineObject);
        /// <summary>
        /// Update position risk limit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Task of Position</returns>
        Task<Position> UpdatePositionRiskLimitAsync (string settle, string contract, string riskLimit);

        /// <summary>
        /// Update position risk limit
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        Task<ApiResponse<Position>> UpdatePositionRiskLimitAsyncWithHttpInfo (string settle, string contract, string riskLimit);
        /// <summary>
        /// Enable or disable dual mode
        /// </summary>
        /// <remarks>
        /// Before setting dual mode, make sure all positions are closed and no orders are open
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>Task of FuturesAccount</returns>
        Task<FuturesAccount> SetDualModeAsync (string settle, bool dualMode);

        /// <summary>
        /// Enable or disable dual mode
        /// </summary>
        /// <remarks>
        /// Before setting dual mode, make sure all positions are closed and no orders are open
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>Task of ApiResponse (FuturesAccount)</returns>
        Task<ApiResponse<FuturesAccount>> SetDualModeAsyncWithHttpInfo (string settle, bool dualMode);
        /// <summary>
        /// Retrieve position detail in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> GetDualModePositionAsync (string settle, string contract);

        /// <summary>
        /// Retrieve position detail in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> GetDualModePositionAsyncWithHttpInfo (string settle, string contract);
        /// <summary>
        /// Update position margin in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> UpdateDualModePositionMarginAsync (string settle, string contract, string change, string dualSide);

        /// <summary>
        /// Update position margin in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> UpdateDualModePositionMarginAsyncWithHttpInfo (string settle, string contract, string change, string dualSide);
        /// <summary>
        /// Update position leverage in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> UpdateDualModePositionLeverageAsync (string settle, string contract, string leverage, string crossLeverageLimit = default(string));

        /// <summary>
        /// Update position leverage in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> UpdateDualModePositionLeverageAsyncWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string));
        /// <summary>
        /// Update position risk limit in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        Task<List<Position>> UpdateDualModePositionRiskLimitAsync (string settle, string contract, string riskLimit);

        /// <summary>
        /// Update position risk limit in dual mode
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        Task<ApiResponse<List<Position>>> UpdateDualModePositionRiskLimitAsyncWithHttpInfo (string settle, string contract, string riskLimit);
        /// <summary>
        /// List futures orders
        /// </summary>
        /// <remarks>
        /// - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/orders_timerange&#x60;.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        Task<List<FuturesOrder>> ListFuturesOrdersAsync (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));

        /// <summary>
        /// List futures orders
        /// </summary>
        /// <remarks>
        /// - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/orders_timerange&#x60;.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesOrder>>> ListFuturesOrdersAsyncWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));
        /// <summary>
        /// Create a futures order
        /// </summary>
        /// <remarks>
        /// - When placing an order, the number of contracts is specified &#x60;size&#x60;, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface &#x60;quanto_multiplier&#x60; - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting &#x60;reduce_only&#x60; to &#x60;true&#x60; can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual warehouse mode,   - Reduce position: reduce_only&#x3D;true, size is a positive number that indicates short position, negative number that indicates long position  - Add position: reduce_only&#x3D;false, size is a positive number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size&#x3D;0, set the direction of closing position according to auto_size, and set &#x60;reduce_only&#x60; to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set &#x60;stp_act&#x60; to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter &#x60;stp_act&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of FuturesOrder</returns>
        Task<FuturesOrder> CreateFuturesOrderAsync (string settle, FuturesOrder futuresOrder, string xGateExptime = default(string));

        /// <summary>
        /// Create a futures order
        /// </summary>
        /// <remarks>
        /// - When placing an order, the number of contracts is specified &#x60;size&#x60;, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface &#x60;quanto_multiplier&#x60; - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting &#x60;reduce_only&#x60; to &#x60;true&#x60; can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual warehouse mode,   - Reduce position: reduce_only&#x3D;true, size is a positive number that indicates short position, negative number that indicates long position  - Add position: reduce_only&#x3D;false, size is a positive number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size&#x3D;0, set the direction of closing position according to auto_size, and set &#x60;reduce_only&#x60; to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set &#x60;stp_act&#x60; to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter &#x60;stp_act&#x60;
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        Task<ApiResponse<FuturesOrder>> CreateFuturesOrderAsyncWithHttpInfo (string settle, FuturesOrder futuresOrder, string xGateExptime = default(string));
        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <param name="side">Specify all buy orders or all sell orders, if not specify them, both are included. Revoke all buy orders and revoke all sell orders and make ask (optional)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        Task<List<FuturesOrder>> CancelFuturesOrdersAsync (string settle, string contract, string xGateExptime = default(string), string side = default(string));

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched
        /// </summary>
        /// <remarks>
        /// Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <param name="side">Specify all buy orders or all sell orders, if not specify them, both are included. Revoke all buy orders and revoke all sell orders and make ask (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesOrder>>> CancelFuturesOrdersAsyncWithHttpInfo (string settle, string contract, string xGateExptime = default(string), string side = default(string));
        /// <summary>
        /// List Futures Orders By Time Range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        Task<List<FuturesOrder>> GetOrdersWithTimeRangeAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List Futures Orders By Time Range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesOrder>>> GetOrdersWithTimeRangeAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Create a batch of futures orders
        /// </summary>
        /// <remarks>
        /// - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;BatchFuturesOrder&gt;</returns>
        Task<List<BatchFuturesOrder>> CreateBatchFuturesOrderAsync (string settle, List<FuturesOrder> futuresOrder, string xGateExptime = default(string));

        /// <summary>
        /// Create a batch of futures orders
        /// </summary>
        /// <remarks>
        /// - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BatchFuturesOrder&gt;)</returns>
        Task<ApiResponse<List<BatchFuturesOrder>>> CreateBatchFuturesOrderAsyncWithHttpInfo (string settle, List<FuturesOrder> futuresOrder, string xGateExptime = default(string));
        /// <summary>
        /// Get a single order
        /// </summary>
        /// <remarks>
        /// - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of FuturesOrder</returns>
        Task<FuturesOrder> GetFuturesOrderAsync (string settle, string orderId);

        /// <summary>
        /// Get a single order
        /// </summary>
        /// <remarks>
        /// - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        Task<ApiResponse<FuturesOrder>> GetFuturesOrderAsyncWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// Amend an order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of FuturesOrder</returns>
        Task<FuturesOrder> AmendFuturesOrderAsync (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment, string xGateExptime = default(string));

        /// <summary>
        /// Amend an order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        Task<ApiResponse<FuturesOrder>> AmendFuturesOrderAsyncWithHttpInfo (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment, string xGateExptime = default(string));
        /// <summary>
        /// Cancel a single order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of FuturesOrder</returns>
        Task<FuturesOrder> CancelFuturesOrderAsync (string settle, string orderId, string xGateExptime = default(string));

        /// <summary>
        /// Cancel a single order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        Task<ApiResponse<FuturesOrder>> CancelFuturesOrderAsyncWithHttpInfo (string settle, string orderId, string xGateExptime = default(string));
        /// <summary>
        /// List personal trading history
        /// </summary>
        /// <remarks>
        /// By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/my_trades_timerange&#x60;.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)</param>
        /// <returns>Task of List&lt;MyFuturesTrade&gt;</returns>
        Task<List<MyFuturesTrade>> GetMyTradesAsync (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));

        /// <summary>
        /// List personal trading history
        /// </summary>
        /// <remarks>
        /// By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/my_trades_timerange&#x60;.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;MyFuturesTrade&gt;)</returns>
        Task<ApiResponse<List<MyFuturesTrade>>> GetMyTradesAsyncWithHttpInfo (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string));
        /// <summary>
        /// List personal trading history by time range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="role">Query role, maker or taker. (optional)</param>
        /// <returns>Task of List&lt;MyFuturesTradeTimeRange&gt;</returns>
        Task<List<MyFuturesTradeTimeRange>> GetMyTradesWithTimeRangeAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?), string role = default(string));

        /// <summary>
        /// List personal trading history by time range
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="role">Query role, maker or taker. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;MyFuturesTradeTimeRange&gt;)</returns>
        Task<ApiResponse<List<MyFuturesTradeTimeRange>>> GetMyTradesWithTimeRangeAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?), string role = default(string));
        /// <summary>
        /// List position close history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="side">Query side.  long or shot (optional)</param>
        /// <param name="pnl">Query profit or loss (optional)</param>
        /// <returns>Task of List&lt;PositionClose&gt;</returns>
        Task<List<PositionClose>> ListPositionCloseAsync (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string side = default(string), string pnl = default(string));

        /// <summary>
        /// List position close history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="side">Query side.  long or shot (optional)</param>
        /// <param name="pnl">Query profit or loss (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;PositionClose&gt;)</returns>
        Task<ApiResponse<List<PositionClose>>> ListPositionCloseAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string side = default(string), string pnl = default(string));
        /// <summary>
        /// List liquidation history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesLiquidate&gt;</returns>
        Task<List<FuturesLiquidate>> ListLiquidatesAsync (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));

        /// <summary>
        /// List liquidation history
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLiquidate&gt;)</returns>
        Task<ApiResponse<List<FuturesLiquidate>>> ListLiquidatesAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));
        /// <summary>
        /// List Auto-Deleveraging History
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesAutoDeleverage&gt;</returns>
        Task<List<FuturesAutoDeleverage>> ListAutoDeleveragesAsync (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));

        /// <summary>
        /// List Auto-Deleveraging History
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesAutoDeleverage&gt;)</returns>
        Task<ApiResponse<List<FuturesAutoDeleverage>>> ListAutoDeleveragesAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?));
        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>Task of TriggerTime</returns>
        Task<TriggerTime> CountdownCancelAllFuturesAsync (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask);

        /// <summary>
        /// Countdown cancel orders
        /// </summary>
        /// <remarks>
        /// When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>Task of ApiResponse (TriggerTime)</returns>
        Task<ApiResponse<TriggerTime>> CountdownCancelAllFuturesAsyncWithHttpInfo (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask);
        /// <summary>
        /// Query user trading fee rates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of Dictionary&lt;string, FuturesFee&gt;</returns>
        Task<Dictionary<string, FuturesFee>> GetFuturesFeeAsync (string settle, string contract = default(string));

        /// <summary>
        /// Query user trading fee rates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, FuturesFee&gt;)</returns>
        Task<ApiResponse<Dictionary<string, FuturesFee>>> GetFuturesFeeAsyncWithHttpInfo (string settle, string contract = default(string));
        /// <summary>
        /// Cancel a batch of orders with an ID list
        /// </summary>
        /// <remarks>
        /// Multiple distinct order ID list can be specified。Each request can cancel a maximum of 20 records.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="requestBody"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;FutureCancelOrderResult&gt;</returns>
        Task<List<FutureCancelOrderResult>> CancelBatchFutureOrdersAsync (string settle, List<string> requestBody, string xGateExptime = default(string));

        /// <summary>
        /// Cancel a batch of orders with an ID list
        /// </summary>
        /// <remarks>
        /// Multiple distinct order ID list can be specified。Each request can cancel a maximum of 20 records.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="requestBody"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FutureCancelOrderResult&gt;)</returns>
        Task<ApiResponse<List<FutureCancelOrderResult>>> CancelBatchFutureOrdersAsyncWithHttpInfo (string settle, List<string> requestBody, string xGateExptime = default(string));
        /// <summary>
        /// Batch modify orders with specified IDs
        /// </summary>
        /// <remarks>
        /// You can specify multiple different order IDs. You can only modify up to 10 orders in one request.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="batchAmendOrderReq"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;BatchFuturesOrder&gt;</returns>
        Task<List<BatchFuturesOrder>> AmendBatchFutureOrdersAsync (string settle, List<BatchAmendOrderReq> batchAmendOrderReq, string xGateExptime = default(string));

        /// <summary>
        /// Batch modify orders with specified IDs
        /// </summary>
        /// <remarks>
        /// You can specify multiple different order IDs. You can only modify up to 10 orders in one request.
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="batchAmendOrderReq"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BatchFuturesOrder&gt;)</returns>
        Task<ApiResponse<List<BatchFuturesOrder>>> AmendBatchFutureOrdersAsyncWithHttpInfo (string settle, List<BatchAmendOrderReq> batchAmendOrderReq, string xGateExptime = default(string));
        /// <summary>
        /// List All Price-triggered Orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        Task<List<FuturesPriceTriggeredOrder>> ListPriceTriggeredOrdersAsync (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?));

        /// <summary>
        /// List All Price-triggered Orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPriceTriggeredOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesPriceTriggeredOrder>>> ListPriceTriggeredOrdersAsyncWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?));
        /// <summary>
        /// Create a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>Task of TriggerOrderResponse</returns>
        Task<TriggerOrderResponse> CreatePriceTriggeredOrderAsync (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder);

        /// <summary>
        /// Create a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>Task of ApiResponse (TriggerOrderResponse)</returns>
        Task<ApiResponse<TriggerOrderResponse>> CreatePriceTriggeredOrderAsyncWithHttpInfo (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder);
        /// <summary>
        /// Cancel All Price-triggered Orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        Task<List<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderListAsync (string settle, string contract = default(string));

        /// <summary>
        /// Cancel All Price-triggered Orders
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPriceTriggeredOrder&gt;)</returns>
        Task<ApiResponse<List<FuturesPriceTriggeredOrder>>> CancelPriceTriggeredOrderListAsyncWithHttpInfo (string settle, string contract = default(string));
        /// <summary>
        /// Get a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of FuturesPriceTriggeredOrder</returns>
        Task<FuturesPriceTriggeredOrder> GetPriceTriggeredOrderAsync (string settle, string orderId);

        /// <summary>
        /// Get a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of ApiResponse (FuturesPriceTriggeredOrder)</returns>
        Task<ApiResponse<FuturesPriceTriggeredOrder>> GetPriceTriggeredOrderAsyncWithHttpInfo (string settle, string orderId);
        /// <summary>
        /// cancel a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of FuturesPriceTriggeredOrder</returns>
        Task<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderAsync (string settle, string orderId);

        /// <summary>
        /// cancel a price-triggered order
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of ApiResponse (FuturesPriceTriggeredOrder)</returns>
        Task<ApiResponse<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderAsyncWithHttpInfo (string settle, string orderId);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IFuturesApi : IFuturesApiSync, IFuturesApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class FuturesApi : IFuturesApi
    {
        private ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public FuturesApi() : this((string) null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public FuturesApi(string basePath)
        {
            this.Configuration = Io.Gate.GateApi.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                new Configuration { BasePath = basePath }
            );
            this.Client = new ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Io.Gate.GateApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public FuturesApi(Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Io.Gate.GateApi.Client.Configuration.MergeConfigurations(
                GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Io.Gate.GateApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="FuturesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public FuturesApi(ISynchronousClient client,IAsynchronousClient asyncClient, IReadableConfiguration configuration)
        {
            if(client == null) throw new ArgumentNullException("client");
            if(asyncClient == null) throw new ArgumentNullException("asyncClient");
            if(configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Io.Gate.GateApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IReadableConfiguration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// List all futures contracts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;Contract&gt;</returns>
        public List<Contract> ListFuturesContracts (string settle, int? limit = default(int?), int? offset = default(int?))
        {
             ApiResponse<List<Contract>> localVarResponse = ListFuturesContractsWithHttpInfo(settle, limit, offset);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List all futures contracts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;Contract&gt;</returns>
        public ApiResponse<List<Contract>> ListFuturesContractsWithHttpInfo (string settle, int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesContracts");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Contract>>("/futures/{settle}/contracts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesContracts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all futures contracts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;Contract&gt;</returns>
        public async Task<List<Contract>> ListFuturesContractsAsync (string settle, int? limit = default(int?), int? offset = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Contract>> localVarResponse = await ListFuturesContractsAsyncWithHttpInfo(settle, limit, offset);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List all futures contracts 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;Contract&gt;)</returns>
        public async Task<ApiResponse<List<Contract>>> ListFuturesContractsAsyncWithHttpInfo (string settle, int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesContracts");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Contract>>("/futures/{settle}/contracts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesContracts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single contract 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Contract</returns>
        public Contract GetFuturesContract (string settle, string contract)
        {
             ApiResponse<Contract> localVarResponse = GetFuturesContractWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single contract 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of Contract</returns>
        public ApiResponse<Contract> GetFuturesContractWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesContract");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetFuturesContract");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<Contract>("/futures/{settle}/contracts/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single contract 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of Contract</returns>
        public async Task<Contract> GetFuturesContractAsync (string settle, string contract)
        {
             Io.Gate.GateApi.Client.ApiResponse<Contract> localVarResponse = await GetFuturesContractAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single contract 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (Contract)</returns>
        public async Task<ApiResponse<Contract>> GetFuturesContractAsyncWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesContract");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetFuturesContract");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Contract>("/futures/{settle}/contracts/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesContract", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures order book Bids will be sorted by price from high to low, while asks sorted reversely
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>FuturesOrderBook</returns>
        public FuturesOrderBook ListFuturesOrderBook (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
             ApiResponse<FuturesOrderBook> localVarResponse = ListFuturesOrderBookWithHttpInfo(settle, contract, interval, limit, withId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Futures order book Bids will be sorted by price from high to low, while asks sorted reversely
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>ApiResponse of FuturesOrderBook</returns>
        public ApiResponse<FuturesOrderBook> ListFuturesOrderBookWithHttpInfo (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesOrderBook");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesOrderBook");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (withId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "with_id", withId));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesOrderBook>("/futures/{settle}/order_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesOrderBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures order book Bids will be sorted by price from high to low, while asks sorted reversely
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>Task of FuturesOrderBook</returns>
        public async Task<FuturesOrderBook> ListFuturesOrderBookAsync (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrderBook> localVarResponse = await ListFuturesOrderBookAsyncWithHttpInfo(settle, contract, interval, limit, withId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Futures order book Bids will be sorted by price from high to low, while asks sorted reversely
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="interval">Order depth. 0 means no aggregation is applied. default to 0 (optional, default to &quot;0&quot;)</param>
        /// <param name="limit">Maximum number of order depth data in asks or bids (optional, default to 10)</param>
        /// <param name="withId">Whether the order book update ID will be returned. This ID increases by 1 on every order book update (optional, default to false)</param>
        /// <returns>Task of ApiResponse (FuturesOrderBook)</returns>
        public async Task<ApiResponse<FuturesOrderBook>> ListFuturesOrderBookAsyncWithHttpInfo (string settle, string contract, string interval = default(string), int? limit = default(int?), bool? withId = default(bool?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesOrderBook");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesOrderBook");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (withId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "with_id", withId));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesOrderBook>("/futures/{settle}/order_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesOrderBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>List&lt;FuturesTrade&gt;</returns>
        public List<FuturesTrade> ListFuturesTrades (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?))
        {
             ApiResponse<List<FuturesTrade>> localVarResponse = ListFuturesTradesWithHttpInfo(settle, contract, limit, offset, lastId, from, to);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Futures trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesTrade&gt;</returns>
        public ApiResponse<List<FuturesTrade>> ListFuturesTradesWithHttpInfo (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesTrades");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesTrades");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesTrade>>("/futures/{settle}/trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>Task of List&lt;FuturesTrade&gt;</returns>
        public async Task<List<FuturesTrade>> ListFuturesTradesAsync (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesTrade>> localVarResponse = await ListFuturesTradesAsyncWithHttpInfo(settle, contract, limit, offset, lastId, from, to);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Futures trading history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range (optional)</param>
        /// <param name="from">Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.  (optional)</param>
        /// <param name="to">Specify end time in Unix seconds, default to current time (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesTrade&gt;)</returns>
        public async Task<ApiResponse<List<FuturesTrade>>> ListFuturesTradesAsyncWithHttpInfo (string settle, string contract, int? limit = default(int?), int? offset = default(int?), string lastId = default(string), long? from = default(long?), long? to = default(long?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesTrades");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesTrades");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesTrade>>("/futures/{settle}/trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get futures candlesticks Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0.  Note that 30d means 1 natual month, not 30 days (optional, default to &quot;5m&quot;)</param>
        /// <returns>List&lt;FuturesCandlestick&gt;</returns>
        public List<FuturesCandlestick> ListFuturesCandlesticks (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
             ApiResponse<List<FuturesCandlestick>> localVarResponse = ListFuturesCandlesticksWithHttpInfo(settle, contract, from, to, limit, interval);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get futures candlesticks Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0.  Note that 30d means 1 natual month, not 30 days (optional, default to &quot;5m&quot;)</param>
        /// <returns>ApiResponse of List&lt;FuturesCandlestick&gt;</returns>
        public ApiResponse<List<FuturesCandlestick>> ListFuturesCandlesticksWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesCandlesticks");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesCandlesticks");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesCandlestick>>("/futures/{settle}/candlesticks", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesCandlesticks", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get futures candlesticks Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0.  Note that 30d means 1 natual month, not 30 days (optional, default to &quot;5m&quot;)</param>
        /// <returns>Task of List&lt;FuturesCandlestick&gt;</returns>
        public async Task<List<FuturesCandlestick>> ListFuturesCandlesticksAsync (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesCandlestick>> localVarResponse = await ListFuturesCandlesticksAsyncWithHttpInfo(settle, contract, from, to, limit, interval);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get futures candlesticks Return specified contract candlesticks. If prefix &#x60;contract&#x60; with &#x60;mark_&#x60;, the contract&#39;s mark price candlesticks are returned; if prefix with &#x60;index_&#x60;, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying &#x60;from&#x60;, &#x60;to&#x60; and &#x60;interval&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points. Note that &#x60;1w&#x60; means natual week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0.  Note that 30d means 1 natual month, not 30 days (optional, default to &quot;5m&quot;)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesCandlestick&gt;)</returns>
        public async Task<ApiResponse<List<FuturesCandlestick>>> ListFuturesCandlesticksAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesCandlesticks");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesCandlesticks");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesCandlestick>>("/futures/{settle}/candlesticks", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesCandlesticks", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Premium Index K-Line Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to &quot;5m&quot;)</param>
        /// <returns>List&lt;FuturesPremiumIndex&gt;</returns>
        public List<FuturesPremiumIndex> ListFuturesPremiumIndex (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
             ApiResponse<List<FuturesPremiumIndex>> localVarResponse = ListFuturesPremiumIndexWithHttpInfo(settle, contract, from, to, limit, interval);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Premium Index K-Line Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to &quot;5m&quot;)</param>
        /// <returns>ApiResponse of List&lt;FuturesPremiumIndex&gt;</returns>
        public ApiResponse<List<FuturesPremiumIndex>> ListFuturesPremiumIndexWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesPremiumIndex");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesPremiumIndex");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesPremiumIndex>>("/futures/{settle}/premium_index", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesPremiumIndex", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Premium Index K-Line Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to &quot;5m&quot;)</param>
        /// <returns>Task of List&lt;FuturesPremiumIndex&gt;</returns>
        public async Task<List<FuturesPremiumIndex>> ListFuturesPremiumIndexAsync (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesPremiumIndex>> localVarResponse = await ListFuturesPremiumIndexAsyncWithHttpInfo(settle, contract, from, to, limit, interval);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Premium Index K-Line Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified (optional)</param>
        /// <param name="to">End time of candlesticks, formatted in Unix timestamp in seconds. Default to current time (optional)</param>
        /// <param name="limit">Maximum recent data points to return. &#x60;limit&#x60; is conflicted with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected. (optional, default to 100)</param>
        /// <param name="interval">Interval time between data points (optional, default to &quot;5m&quot;)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPremiumIndex&gt;)</returns>
        public async Task<ApiResponse<List<FuturesPremiumIndex>>> ListFuturesPremiumIndexAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), long? to = default(long?), int? limit = default(int?), string interval = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesPremiumIndex");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesPremiumIndex");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesPremiumIndex>>("/futures/{settle}/premium_index", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesPremiumIndex", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List futures tickers 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>List&lt;FuturesTicker&gt;</returns>
        public List<FuturesTicker> ListFuturesTickers (string settle, string contract = default(string))
        {
             ApiResponse<List<FuturesTicker>> localVarResponse = ListFuturesTickersWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List futures tickers 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesTicker&gt;</returns>
        public ApiResponse<List<FuturesTicker>> ListFuturesTickersWithHttpInfo (string settle, string contract = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesTickers");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesTicker>>("/futures/{settle}/tickers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesTickers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List futures tickers 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of List&lt;FuturesTicker&gt;</returns>
        public async Task<List<FuturesTicker>> ListFuturesTickersAsync (string settle, string contract = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesTicker>> localVarResponse = await ListFuturesTickersAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List futures tickers 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesTicker&gt;)</returns>
        public async Task<ApiResponse<List<FuturesTicker>>> ListFuturesTickersAsyncWithHttpInfo (string settle, string contract = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesTickers");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesTicker>>("/futures/{settle}/tickers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesTickers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Funding rate history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>List&lt;FundingRateRecord&gt;</returns>
        public List<FundingRateRecord> ListFuturesFundingRateHistory (string settle, string contract, int? limit = default(int?), long? from = default(long?), long? to = default(long?))
        {
             ApiResponse<List<FundingRateRecord>> localVarResponse = ListFuturesFundingRateHistoryWithHttpInfo(settle, contract, limit, from, to);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Funding rate history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>ApiResponse of List&lt;FundingRateRecord&gt;</returns>
        public ApiResponse<List<FundingRateRecord>> ListFuturesFundingRateHistoryWithHttpInfo (string settle, string contract, int? limit = default(int?), long? from = default(long?), long? to = default(long?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesFundingRateHistory");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesFundingRateHistory");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FundingRateRecord>>("/futures/{settle}/funding_rate", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesFundingRateHistory", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Funding rate history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>Task of List&lt;FundingRateRecord&gt;</returns>
        public async Task<List<FundingRateRecord>> ListFuturesFundingRateHistoryAsync (string settle, string contract, int? limit = default(int?), long? from = default(long?), long? to = default(long?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FundingRateRecord>> localVarResponse = await ListFuturesFundingRateHistoryAsyncWithHttpInfo(settle, contract, limit, from, to);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Funding rate history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FundingRateRecord&gt;)</returns>
        public async Task<ApiResponse<List<FundingRateRecord>>> ListFuturesFundingRateHistoryAsyncWithHttpInfo (string settle, string contract, int? limit = default(int?), long? from = default(long?), long? to = default(long?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesFundingRateHistory");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListFuturesFundingRateHistory");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FundingRateRecord>>("/futures/{settle}/funding_rate", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesFundingRateHistory", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures insurance balance history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;InsuranceRecord&gt;</returns>
        public List<InsuranceRecord> ListFuturesInsuranceLedger (string settle, int? limit = default(int?))
        {
             ApiResponse<List<InsuranceRecord>> localVarResponse = ListFuturesInsuranceLedgerWithHttpInfo(settle, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Futures insurance balance history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;InsuranceRecord&gt;</returns>
        public ApiResponse<List<InsuranceRecord>> ListFuturesInsuranceLedgerWithHttpInfo (string settle, int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesInsuranceLedger");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<InsuranceRecord>>("/futures/{settle}/insurance", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesInsuranceLedger", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures insurance balance history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;InsuranceRecord&gt;</returns>
        public async Task<List<InsuranceRecord>> ListFuturesInsuranceLedgerAsync (string settle, int? limit = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<InsuranceRecord>> localVarResponse = await ListFuturesInsuranceLedgerAsyncWithHttpInfo(settle, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Futures insurance balance history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;InsuranceRecord&gt;)</returns>
        public async Task<ApiResponse<List<InsuranceRecord>>> ListFuturesInsuranceLedgerAsyncWithHttpInfo (string settle, int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesInsuranceLedger");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<InsuranceRecord>>("/futures/{settle}/insurance", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesInsuranceLedger", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures stats 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to &quot;5m&quot;)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>List&lt;ContractStat&gt;</returns>
        public List<ContractStat> ListContractStats (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?))
        {
             ApiResponse<List<ContractStat>> localVarResponse = ListContractStatsWithHttpInfo(settle, contract, from, interval, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Futures stats 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to &quot;5m&quot;)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>ApiResponse of List&lt;ContractStat&gt;</returns>
        public ApiResponse<List<ContractStat>> ListContractStatsWithHttpInfo (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListContractStats");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListContractStats");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<ContractStat>>("/futures/{settle}/contract_stats", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListContractStats", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Futures stats 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to &quot;5m&quot;)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>Task of List&lt;ContractStat&gt;</returns>
        public async Task<List<ContractStat>> ListContractStatsAsync (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<ContractStat>> localVarResponse = await ListContractStatsAsyncWithHttpInfo(settle, contract, from, interval, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Futures stats 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="interval"> (optional, default to &quot;5m&quot;)</param>
        /// <param name="limit"> (optional, default to 30)</param>
        /// <returns>Task of ApiResponse (List&lt;ContractStat&gt;)</returns>
        public async Task<ApiResponse<List<ContractStat>>> ListContractStatsAsyncWithHttpInfo (string settle, string contract, long? from = default(long?), string interval = default(string), int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListContractStats");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->ListContractStats");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (interval != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "interval", interval));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<ContractStat>>("/futures/{settle}/contract_stats", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListContractStats", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get index constituents 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>FuturesIndexConstituents</returns>
        public FuturesIndexConstituents GetIndexConstituents (string settle, string index)
        {
             ApiResponse<FuturesIndexConstituents> localVarResponse = GetIndexConstituentsWithHttpInfo(settle, index);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get index constituents 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>ApiResponse of FuturesIndexConstituents</returns>
        public ApiResponse<FuturesIndexConstituents> GetIndexConstituentsWithHttpInfo (string settle, string index)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetIndexConstituents");

            // verify the required parameter 'index' is set
            if (index == null)
                throw new ApiException(400, "Missing required parameter 'index' when calling FuturesApi->GetIndexConstituents");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesIndexConstituents>("/futures/{settle}/index_constituents/{index}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIndexConstituents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get index constituents 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>Task of FuturesIndexConstituents</returns>
        public async Task<FuturesIndexConstituents> GetIndexConstituentsAsync (string settle, string index)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesIndexConstituents> localVarResponse = await GetIndexConstituentsAsyncWithHttpInfo(settle, index);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get index constituents 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="index">Index name</param>
        /// <returns>Task of ApiResponse (FuturesIndexConstituents)</returns>
        public async Task<ApiResponse<FuturesIndexConstituents>> GetIndexConstituentsAsyncWithHttpInfo (string settle, string index)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetIndexConstituents");

            // verify the required parameter 'index' is set
            if (index == null)
                throw new ApiException(400, "Missing required parameter 'index' when calling FuturesApi->GetIndexConstituents");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("index", ClientUtils.ParameterToString(index)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesIndexConstituents>("/futures/{settle}/index_constituents/{index}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIndexConstituents", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve liquidation history Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>List&lt;FuturesLiqOrder&gt;</returns>
        public List<FuturesLiqOrder> ListLiquidatedOrders (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?))
        {
             ApiResponse<List<FuturesLiqOrder>> localVarResponse = ListLiquidatedOrdersWithHttpInfo(settle, contract, from, to, limit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve liquidation history Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>ApiResponse of List&lt;FuturesLiqOrder&gt;</returns>
        public ApiResponse<List<FuturesLiqOrder>> ListLiquidatedOrdersWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListLiquidatedOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesLiqOrder>>("/futures/{settle}/liq_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLiquidatedOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve liquidation history Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of List&lt;FuturesLiqOrder&gt;</returns>
        public async Task<List<FuturesLiqOrder>> ListLiquidatedOrdersAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesLiqOrder>> localVarResponse = await ListLiquidatedOrdersAsyncWithHttpInfo(settle, contract, from, to, limit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieve liquidation history Interval between &#x60;from&#x60; and &#x60;to&#x60; cannot exceeds 3600. Some private fields will not be returned in public endpoints. Refer to field description for detail.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLiqOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesLiqOrder>>> ListLiquidatedOrdersAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListLiquidatedOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesLiqOrder>>("/futures/{settle}/liq_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLiquidatedOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List risk limit tiers When the &#39;contract&#39; parameter is not passed, the default is to query the risk limits for the top 100 markets.&#39;Limit&#39; and &#39;offset&#39; correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the &#39;contract&#39; parameter is empty.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;FuturesLimitRiskTiers&gt;</returns>
        public List<FuturesLimitRiskTiers> ListFuturesRiskLimitTiers (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
             ApiResponse<List<FuturesLimitRiskTiers>> localVarResponse = ListFuturesRiskLimitTiersWithHttpInfo(settle, contract, limit, offset);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List risk limit tiers When the &#39;contract&#39; parameter is not passed, the default is to query the risk limits for the top 100 markets.&#39;Limit&#39; and &#39;offset&#39; correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the &#39;contract&#39; parameter is empty.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesLimitRiskTiers&gt;</returns>
        public ApiResponse<List<FuturesLimitRiskTiers>> ListFuturesRiskLimitTiersWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesRiskLimitTiers");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesLimitRiskTiers>>("/futures/{settle}/risk_limit_tiers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesRiskLimitTiers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List risk limit tiers When the &#39;contract&#39; parameter is not passed, the default is to query the risk limits for the top 100 markets.&#39;Limit&#39; and &#39;offset&#39; correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the &#39;contract&#39; parameter is empty.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesLimitRiskTiers&gt;</returns>
        public async Task<List<FuturesLimitRiskTiers>> ListFuturesRiskLimitTiersAsync (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesLimitRiskTiers>> localVarResponse = await ListFuturesRiskLimitTiersAsyncWithHttpInfo(settle, contract, limit, offset);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List risk limit tiers When the &#39;contract&#39; parameter is not passed, the default is to query the risk limits for the top 100 markets.&#39;Limit&#39; and &#39;offset&#39; correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the &#39;contract&#39; parameter is empty.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLimitRiskTiers&gt;)</returns>
        public async Task<ApiResponse<List<FuturesLimitRiskTiers>>> ListFuturesRiskLimitTiersAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesRiskLimitTiers");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesLimitRiskTiers>>("/futures/{settle}/risk_limit_tiers", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesRiskLimitTiers", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query futures account 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>FuturesAccount</returns>
        public FuturesAccount ListFuturesAccounts (string settle)
        {
             ApiResponse<FuturesAccount> localVarResponse = ListFuturesAccountsWithHttpInfo(settle);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query futures account 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>ApiResponse of FuturesAccount</returns>
        public ApiResponse<FuturesAccount> ListFuturesAccountsWithHttpInfo (string settle)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesAccounts");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesAccount>("/futures/{settle}/accounts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesAccounts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query futures account 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of FuturesAccount</returns>
        public async Task<FuturesAccount> ListFuturesAccountsAsync (string settle)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesAccount> localVarResponse = await ListFuturesAccountsAsyncWithHttpInfo(settle);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query futures account 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <returns>Task of ApiResponse (FuturesAccount)</returns>
        public async Task<ApiResponse<FuturesAccount>> ListFuturesAccountsAsyncWithHttpInfo (string settle)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesAccounts");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesAccount>("/futures/{settle}/accounts", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesAccounts", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query account book If the &#x60;contract&#x60; field is provided, it can only filter records that include this field after 2023-10-30.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)</param>
        /// <returns>List&lt;FuturesAccountBook&gt;</returns>
        public List<FuturesAccountBook> ListFuturesAccountBook (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string))
        {
             ApiResponse<List<FuturesAccountBook>> localVarResponse = ListFuturesAccountBookWithHttpInfo(settle, contract, limit, offset, from, to, type);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query account book If the &#x60;contract&#x60; field is provided, it can only filter records that include this field after 2023-10-30.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesAccountBook&gt;</returns>
        public ApiResponse<List<FuturesAccountBook>> ListFuturesAccountBookWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesAccountBook");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (type != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "type", type));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesAccountBook>>("/futures/{settle}/account_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesAccountBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query account book If the &#x60;contract&#x60; field is provided, it can only filter records that include this field after 2023-10-30.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)</param>
        /// <returns>Task of List&lt;FuturesAccountBook&gt;</returns>
        public async Task<List<FuturesAccountBook>> ListFuturesAccountBookAsync (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesAccountBook>> localVarResponse = await ListFuturesAccountBookAsyncWithHttpInfo(settle, contract, limit, offset, from, to, type);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query account book If the &#x60;contract&#x60; field is provided, it can only filter records that include this field after 2023-10-30.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="type">Changing Type：  - dnw: Deposit &amp; Withdraw - pnl: Profit &amp; Loss by reducing position - fee: Trading fee - refr: Referrer rebate - fund: Funding - point_dnw: POINT Deposit &amp; Withdraw - point_fee: POINT Trading fee - point_refr: POINT Referrer rebate - bonus_offset: bouns deduction (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesAccountBook&gt;)</returns>
        public async Task<ApiResponse<List<FuturesAccountBook>>> ListFuturesAccountBookAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string type = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesAccountBook");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (type != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "type", type));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesAccountBook>>("/futures/{settle}/account_book", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesAccountBook", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all positions of a user 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="holding">Return only real positions - true, return all - false. (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> ListPositions (string settle, bool? holding = default(bool?), int? limit = default(int?), int? offset = default(int?))
        {
             ApiResponse<List<Position>> localVarResponse = ListPositionsWithHttpInfo(settle, holding, limit, offset);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List all positions of a user 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="holding">Return only real positions - true, return all - false. (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> ListPositionsWithHttpInfo (string settle, bool? holding = default(bool?), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPositions");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (holding != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "holding", holding));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Position>>("/futures/{settle}/positions", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPositions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all positions of a user 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="holding">Return only real positions - true, return all - false. (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> ListPositionsAsync (string settle, bool? holding = default(bool?), int? limit = default(int?), int? offset = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await ListPositionsAsyncWithHttpInfo(settle, holding, limit, offset);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List all positions of a user 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="holding">Return only real positions - true, return all - false. (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> ListPositionsAsyncWithHttpInfo (string settle, bool? holding = default(bool?), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPositions");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (holding != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "holding", holding));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Position>>("/futures/{settle}/positions", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPositions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get single position 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Position</returns>
        public Position GetPosition (string settle, string contract)
        {
             ApiResponse<Position> localVarResponse = GetPositionWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get single position 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of Position</returns>
        public ApiResponse<Position> GetPositionWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetPosition");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetPosition");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<Position>("/futures/{settle}/positions/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPosition", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get single position 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of Position</returns>
        public async Task<Position> GetPositionAsync (string settle, string contract)
        {
             Io.Gate.GateApi.Client.ApiResponse<Position> localVarResponse = await GetPositionAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get single position 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        public async Task<ApiResponse<Position>> GetPositionAsyncWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetPosition");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetPosition");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Position>("/futures/{settle}/positions/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPosition", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position margin 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Position</returns>
        public Position UpdatePositionMargin (string settle, string contract, string change)
        {
             ApiResponse<Position> localVarResponse = UpdatePositionMarginWithHttpInfo(settle, contract, change);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position margin 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>ApiResponse of Position</returns>
        public ApiResponse<Position> UpdatePositionMarginWithHttpInfo (string settle, string contract, string change)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionMargin");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionMargin");

            // verify the required parameter 'change' is set
            if (change == null)
                throw new ApiException(400, "Missing required parameter 'change' when calling FuturesApi->UpdatePositionMargin");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "change", change));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<Position>("/futures/{settle}/positions/{contract}/margin", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionMargin", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position margin 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Task of Position</returns>
        public async Task<Position> UpdatePositionMarginAsync (string settle, string contract, string change)
        {
             Io.Gate.GateApi.Client.ApiResponse<Position> localVarResponse = await UpdatePositionMarginAsyncWithHttpInfo(settle, contract, change);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position margin 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        public async Task<ApiResponse<Position>> UpdatePositionMarginAsyncWithHttpInfo (string settle, string contract, string change)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionMargin");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionMargin");

            // verify the required parameter 'change' is set
            if (change == null)
                throw new ApiException(400, "Missing required parameter 'change' when calling FuturesApi->UpdatePositionMargin");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "change", change));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Position>("/futures/{settle}/positions/{contract}/margin", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionMargin", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position leverage 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Position</returns>
        public Position UpdatePositionLeverage (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
             ApiResponse<Position> localVarResponse = UpdatePositionLeverageWithHttpInfo(settle, contract, leverage, crossLeverageLimit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position leverage 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>ApiResponse of Position</returns>
        public ApiResponse<Position> UpdatePositionLeverageWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionLeverage");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionLeverage");

            // verify the required parameter 'leverage' is set
            if (leverage == null)
                throw new ApiException(400, "Missing required parameter 'leverage' when calling FuturesApi->UpdatePositionLeverage");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "leverage", leverage));
            if (crossLeverageLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "cross_leverage_limit", crossLeverageLimit));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<Position>("/futures/{settle}/positions/{contract}/leverage", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionLeverage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position leverage 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of Position</returns>
        public async Task<Position> UpdatePositionLeverageAsync (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<Position> localVarResponse = await UpdatePositionLeverageAsyncWithHttpInfo(settle, contract, leverage, crossLeverageLimit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position leverage 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        public async Task<ApiResponse<Position>> UpdatePositionLeverageAsyncWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionLeverage");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionLeverage");

            // verify the required parameter 'leverage' is set
            if (leverage == null)
                throw new ApiException(400, "Missing required parameter 'leverage' when calling FuturesApi->UpdatePositionLeverage");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "leverage", leverage));
            if (crossLeverageLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "cross_leverage_limit", crossLeverageLimit));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Position>("/futures/{settle}/positions/{contract}/leverage", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionLeverage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Switch to the full position-by-store mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="inlineObject"></param>
        /// <returns>Position</returns>
        public Position UpdatePositionCrossMode (string settle, InlineObject inlineObject)
        {
             ApiResponse<Position> localVarResponse = UpdatePositionCrossModeWithHttpInfo(settle, inlineObject);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Switch to the full position-by-store mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="inlineObject"></param>
        /// <returns>ApiResponse of Position</returns>
        public ApiResponse<Position> UpdatePositionCrossModeWithHttpInfo (string settle, InlineObject inlineObject)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionCrossMode");

            // verify the required parameter 'inlineObject' is set
            if (inlineObject == null)
                throw new ApiException(400, "Missing required parameter 'inlineObject' when calling FuturesApi->UpdatePositionCrossMode");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = inlineObject;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<Position>("/futures/{settle}/positions/cross_mode", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionCrossMode", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Switch to the full position-by-store mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="inlineObject"></param>
        /// <returns>Task of Position</returns>
        public async Task<Position> UpdatePositionCrossModeAsync (string settle, InlineObject inlineObject)
        {
             Io.Gate.GateApi.Client.ApiResponse<Position> localVarResponse = await UpdatePositionCrossModeAsyncWithHttpInfo(settle, inlineObject);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Switch to the full position-by-store mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="inlineObject"></param>
        /// <returns>Task of ApiResponse (Position)</returns>
        public async Task<ApiResponse<Position>> UpdatePositionCrossModeAsyncWithHttpInfo (string settle, InlineObject inlineObject)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionCrossMode");

            // verify the required parameter 'inlineObject' is set
            if (inlineObject == null)
                throw new ApiException(400, "Missing required parameter 'inlineObject' when calling FuturesApi->UpdatePositionCrossMode");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = inlineObject;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Position>("/futures/{settle}/positions/cross_mode", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionCrossMode", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position risk limit 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Position</returns>
        public Position UpdatePositionRiskLimit (string settle, string contract, string riskLimit)
        {
             ApiResponse<Position> localVarResponse = UpdatePositionRiskLimitWithHttpInfo(settle, contract, riskLimit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position risk limit 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>ApiResponse of Position</returns>
        public ApiResponse<Position> UpdatePositionRiskLimitWithHttpInfo (string settle, string contract, string riskLimit)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionRiskLimit");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionRiskLimit");

            // verify the required parameter 'riskLimit' is set
            if (riskLimit == null)
                throw new ApiException(400, "Missing required parameter 'riskLimit' when calling FuturesApi->UpdatePositionRiskLimit");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "risk_limit", riskLimit));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<Position>("/futures/{settle}/positions/{contract}/risk_limit", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionRiskLimit", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position risk limit 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Task of Position</returns>
        public async Task<Position> UpdatePositionRiskLimitAsync (string settle, string contract, string riskLimit)
        {
             Io.Gate.GateApi.Client.ApiResponse<Position> localVarResponse = await UpdatePositionRiskLimitAsyncWithHttpInfo(settle, contract, riskLimit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position risk limit 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Task of ApiResponse (Position)</returns>
        public async Task<ApiResponse<Position>> UpdatePositionRiskLimitAsyncWithHttpInfo (string settle, string contract, string riskLimit)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdatePositionRiskLimit");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdatePositionRiskLimit");

            // verify the required parameter 'riskLimit' is set
            if (riskLimit == null)
                throw new ApiException(400, "Missing required parameter 'riskLimit' when calling FuturesApi->UpdatePositionRiskLimit");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "risk_limit", riskLimit));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<Position>("/futures/{settle}/positions/{contract}/risk_limit", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdatePositionRiskLimit", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Enable or disable dual mode Before setting dual mode, make sure all positions are closed and no orders are open
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>FuturesAccount</returns>
        public FuturesAccount SetDualMode (string settle, bool dualMode)
        {
             ApiResponse<FuturesAccount> localVarResponse = SetDualModeWithHttpInfo(settle, dualMode);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Enable or disable dual mode Before setting dual mode, make sure all positions are closed and no orders are open
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>ApiResponse of FuturesAccount</returns>
        public ApiResponse<FuturesAccount> SetDualModeWithHttpInfo (string settle, bool dualMode)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->SetDualMode");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "dual_mode", dualMode));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<FuturesAccount>("/futures/{settle}/dual_mode", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetDualMode", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Enable or disable dual mode Before setting dual mode, make sure all positions are closed and no orders are open
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>Task of FuturesAccount</returns>
        public async Task<FuturesAccount> SetDualModeAsync (string settle, bool dualMode)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesAccount> localVarResponse = await SetDualModeAsyncWithHttpInfo(settle, dualMode);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Enable or disable dual mode Before setting dual mode, make sure all positions are closed and no orders are open
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="dualMode">Whether to enable dual mode</param>
        /// <returns>Task of ApiResponse (FuturesAccount)</returns>
        public async Task<ApiResponse<FuturesAccount>> SetDualModeAsyncWithHttpInfo (string settle, bool dualMode)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->SetDualMode");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "dual_mode", dualMode));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<FuturesAccount>("/futures/{settle}/dual_mode", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SetDualMode", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve position detail in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> GetDualModePosition (string settle, string contract)
        {
             ApiResponse<List<Position>> localVarResponse = GetDualModePositionWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve position detail in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> GetDualModePositionWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetDualModePosition");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetDualModePosition");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDualModePosition", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve position detail in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> GetDualModePositionAsync (string settle, string contract)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await GetDualModePositionAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Retrieve position detail in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> GetDualModePositionAsyncWithHttpInfo (string settle, string contract)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetDualModePosition");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->GetDualModePosition");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetDualModePosition", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position margin in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> UpdateDualModePositionMargin (string settle, string contract, string change, string dualSide)
        {
             ApiResponse<List<Position>> localVarResponse = UpdateDualModePositionMarginWithHttpInfo(settle, contract, change, dualSide);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position margin in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> UpdateDualModePositionMarginWithHttpInfo (string settle, string contract, string change, string dualSide)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'change' is set
            if (change == null)
                throw new ApiException(400, "Missing required parameter 'change' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'dualSide' is set
            if (dualSide == null)
                throw new ApiException(400, "Missing required parameter 'dualSide' when calling FuturesApi->UpdateDualModePositionMargin");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "change", change));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "dual_side", dualSide));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/margin", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionMargin", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position margin in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> UpdateDualModePositionMarginAsync (string settle, string contract, string change, string dualSide)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await UpdateDualModePositionMarginAsyncWithHttpInfo(settle, contract, change, dualSide);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position margin in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="change">Margin change. Use positive number to increase margin, negative number otherwise.</param>
        /// <param name="dualSide">Long or short position</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> UpdateDualModePositionMarginAsyncWithHttpInfo (string settle, string contract, string change, string dualSide)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'change' is set
            if (change == null)
                throw new ApiException(400, "Missing required parameter 'change' when calling FuturesApi->UpdateDualModePositionMargin");

            // verify the required parameter 'dualSide' is set
            if (dualSide == null)
                throw new ApiException(400, "Missing required parameter 'dualSide' when calling FuturesApi->UpdateDualModePositionMargin");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "change", change));
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "dual_side", dualSide));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/margin", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionMargin", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position leverage in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> UpdateDualModePositionLeverage (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
             ApiResponse<List<Position>> localVarResponse = UpdateDualModePositionLeverageWithHttpInfo(settle, contract, leverage, crossLeverageLimit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position leverage in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> UpdateDualModePositionLeverageWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionLeverage");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionLeverage");

            // verify the required parameter 'leverage' is set
            if (leverage == null)
                throw new ApiException(400, "Missing required parameter 'leverage' when calling FuturesApi->UpdateDualModePositionLeverage");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "leverage", leverage));
            if (crossLeverageLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "cross_leverage_limit", crossLeverageLimit));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/leverage", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionLeverage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position leverage in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> UpdateDualModePositionLeverageAsync (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await UpdateDualModePositionLeverageAsyncWithHttpInfo(settle, contract, leverage, crossLeverageLimit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position leverage in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="leverage">New position leverage</param>
        /// <param name="crossLeverageLimit">Cross margin leverage(valid only when &#x60;leverage&#x60; is 0) (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> UpdateDualModePositionLeverageAsyncWithHttpInfo (string settle, string contract, string leverage, string crossLeverageLimit = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionLeverage");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionLeverage");

            // verify the required parameter 'leverage' is set
            if (leverage == null)
                throw new ApiException(400, "Missing required parameter 'leverage' when calling FuturesApi->UpdateDualModePositionLeverage");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "leverage", leverage));
            if (crossLeverageLimit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "cross_leverage_limit", crossLeverageLimit));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/leverage", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionLeverage", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position risk limit in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>List&lt;Position&gt;</returns>
        public List<Position> UpdateDualModePositionRiskLimit (string settle, string contract, string riskLimit)
        {
             ApiResponse<List<Position>> localVarResponse = UpdateDualModePositionRiskLimitWithHttpInfo(settle, contract, riskLimit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update position risk limit in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>ApiResponse of List&lt;Position&gt;</returns>
        public ApiResponse<List<Position>> UpdateDualModePositionRiskLimitWithHttpInfo (string settle, string contract, string riskLimit)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            // verify the required parameter 'riskLimit' is set
            if (riskLimit == null)
                throw new ApiException(400, "Missing required parameter 'riskLimit' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "risk_limit", riskLimit));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/risk_limit", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionRiskLimit", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Update position risk limit in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Task of List&lt;Position&gt;</returns>
        public async Task<List<Position>> UpdateDualModePositionRiskLimitAsync (string settle, string contract, string riskLimit)
        {
             Io.Gate.GateApi.Client.ApiResponse<List<Position>> localVarResponse = await UpdateDualModePositionRiskLimitAsyncWithHttpInfo(settle, contract, riskLimit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update position risk limit in dual mode 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="riskLimit">New Risk Limit Value</param>
        /// <returns>Task of ApiResponse (List&lt;Position&gt;)</returns>
        public async Task<ApiResponse<List<Position>>> UpdateDualModePositionRiskLimitAsyncWithHttpInfo (string settle, string contract, string riskLimit)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->UpdateDualModePositionRiskLimit");

            // verify the required parameter 'riskLimit' is set
            if (riskLimit == null)
                throw new ApiException(400, "Missing required parameter 'riskLimit' when calling FuturesApi->UpdateDualModePositionRiskLimit");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("contract", ClientUtils.ParameterToString(contract)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "risk_limit", riskLimit));

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<Position>>("/futures/{settle}/dual_comp/positions/{contract}/risk_limit", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UpdateDualModePositionRiskLimit", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List futures orders - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/orders_timerange&#x60;.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        public List<FuturesOrder> ListFuturesOrders (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
             ApiResponse<List<FuturesOrder>> localVarResponse = ListFuturesOrdersWithHttpInfo(settle, status, contract, limit, offset, lastId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List futures orders - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/orders_timerange&#x60;.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        public ApiResponse<List<FuturesOrder>> ListFuturesOrdersWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling FuturesApi->ListFuturesOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesOrder>>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List futures orders - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/orders_timerange&#x60;.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        public async Task<List<FuturesOrder>> ListFuturesOrdersAsync (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesOrder>> localVarResponse = await ListFuturesOrdersAsyncWithHttpInfo(settle, status, contract, limit, offset, lastId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List futures orders - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/orders_timerange&#x60;.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify list staring point using the &#x60;id&#x60; of last record in previous list-query results (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesOrder>>> ListFuturesOrdersAsyncWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListFuturesOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling FuturesApi->ListFuturesOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesOrder>>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListFuturesOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a futures order - When placing an order, the number of contracts is specified &#x60;size&#x60;, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface &#x60;quanto_multiplier&#x60; - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting &#x60;reduce_only&#x60; to &#x60;true&#x60; can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual warehouse mode,   - Reduce position: reduce_only&#x3D;true, size is a positive number that indicates short position, negative number that indicates long position  - Add position: reduce_only&#x3D;false, size is a positive number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size&#x3D;0, set the direction of closing position according to auto_size, and set &#x60;reduce_only&#x60; to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set &#x60;stp_act&#x60; to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter &#x60;stp_act&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>FuturesOrder</returns>
        public FuturesOrder CreateFuturesOrder (string settle, FuturesOrder futuresOrder, string xGateExptime = default(string))
        {
             ApiResponse<FuturesOrder> localVarResponse = CreateFuturesOrderWithHttpInfo(settle, futuresOrder, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a futures order - When placing an order, the number of contracts is specified &#x60;size&#x60;, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface &#x60;quanto_multiplier&#x60; - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting &#x60;reduce_only&#x60; to &#x60;true&#x60; can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual warehouse mode,   - Reduce position: reduce_only&#x3D;true, size is a positive number that indicates short position, negative number that indicates long position  - Add position: reduce_only&#x3D;false, size is a positive number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size&#x3D;0, set the direction of closing position according to auto_size, and set &#x60;reduce_only&#x60; to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set &#x60;stp_act&#x60; to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter &#x60;stp_act&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        public ApiResponse<FuturesOrder> CreateFuturesOrderWithHttpInfo (string settle, FuturesOrder futuresOrder, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreateFuturesOrder");

            // verify the required parameter 'futuresOrder' is set
            if (futuresOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrder' when calling FuturesApi->CreateFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = futuresOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<FuturesOrder>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a futures order - When placing an order, the number of contracts is specified &#x60;size&#x60;, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface &#x60;quanto_multiplier&#x60; - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting &#x60;reduce_only&#x60; to &#x60;true&#x60; can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual warehouse mode,   - Reduce position: reduce_only&#x3D;true, size is a positive number that indicates short position, negative number that indicates long position  - Add position: reduce_only&#x3D;false, size is a positive number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size&#x3D;0, set the direction of closing position according to auto_size, and set &#x60;reduce_only&#x60; to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set &#x60;stp_act&#x60; to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter &#x60;stp_act&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of FuturesOrder</returns>
        public async Task<FuturesOrder> CreateFuturesOrderAsync (string settle, FuturesOrder futuresOrder, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrder> localVarResponse = await CreateFuturesOrderAsyncWithHttpInfo(settle, futuresOrder, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a futures order - When placing an order, the number of contracts is specified &#x60;size&#x60;, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface &#x60;quanto_multiplier&#x60; - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting &#x60;reduce_only&#x60; to &#x60;true&#x60; can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set &#x60;size&#x60; to 0 and &#x60;close&#x60; to &#x60;true&#x60; - In dual warehouse mode,   - Reduce position: reduce_only&#x3D;true, size is a positive number that indicates short position, negative number that indicates long position  - Add position: reduce_only&#x3D;false, size is a positive number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size&#x3D;0, set the direction of closing position according to auto_size, and set &#x60;reduce_only&#x60; to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set &#x60;stp_act&#x60; to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter &#x60;stp_act&#x60;
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        public async Task<ApiResponse<FuturesOrder>> CreateFuturesOrderAsyncWithHttpInfo (string settle, FuturesOrder futuresOrder, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreateFuturesOrder");

            // verify the required parameter 'futuresOrder' is set
            if (futuresOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrder' when calling FuturesApi->CreateFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = futuresOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<FuturesOrder>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <param name="side">Specify all buy orders or all sell orders, if not specify them, both are included. Revoke all buy orders and revoke all sell orders and make ask (optional)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        public List<FuturesOrder> CancelFuturesOrders (string settle, string contract, string xGateExptime = default(string), string side = default(string))
        {
             ApiResponse<List<FuturesOrder>> localVarResponse = CancelFuturesOrdersWithHttpInfo(settle, contract, xGateExptime, side);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <param name="side">Specify all buy orders or all sell orders, if not specify them, both are included. Revoke all buy orders and revoke all sell orders and make ask (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        public ApiResponse<List<FuturesOrder>> CancelFuturesOrdersWithHttpInfo (string settle, string contract, string xGateExptime = default(string), string side = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelFuturesOrders");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->CancelFuturesOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<List<FuturesOrder>>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelFuturesOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <param name="side">Specify all buy orders or all sell orders, if not specify them, both are included. Revoke all buy orders and revoke all sell orders and make ask (optional)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        public async Task<List<FuturesOrder>> CancelFuturesOrdersAsync (string settle, string contract, string xGateExptime = default(string), string side = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesOrder>> localVarResponse = await CancelFuturesOrdersAsyncWithHttpInfo(settle, contract, xGateExptime, side);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel all &#x60;open&#x60; orders matched Zero-filled order cannot be retrieved 10 minutes after order cancellation
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <param name="side">Specify all buy orders or all sell orders, if not specify them, both are included. Revoke all buy orders and revoke all sell orders and make ask (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesOrder>>> CancelFuturesOrdersAsyncWithHttpInfo (string settle, string contract, string xGateExptime = default(string), string side = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelFuturesOrders");

            // verify the required parameter 'contract' is set
            if (contract == null)
                throw new ApiException(400, "Missing required parameter 'contract' when calling FuturesApi->CancelFuturesOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<List<FuturesOrder>>("/futures/{settle}/orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelFuturesOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Futures Orders By Time Range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;FuturesOrder&gt;</returns>
        public List<FuturesOrder> GetOrdersWithTimeRange (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?))
        {
             ApiResponse<List<FuturesOrder>> localVarResponse = GetOrdersWithTimeRangeWithHttpInfo(settle, contract, from, to, limit, offset);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List Futures Orders By Time Range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesOrder&gt;</returns>
        public ApiResponse<List<FuturesOrder>> GetOrdersWithTimeRangeWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetOrdersWithTimeRange");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesOrder>>("/futures/{settle}/orders_timerange", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOrdersWithTimeRange", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Futures Orders By Time Range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesOrder&gt;</returns>
        public async Task<List<FuturesOrder>> GetOrdersWithTimeRangeAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesOrder>> localVarResponse = await GetOrdersWithTimeRangeAsyncWithHttpInfo(settle, contract, from, to, limit, offset);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List Futures Orders By Time Range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesOrder>>> GetOrdersWithTimeRangeAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetOrdersWithTimeRange");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesOrder>>("/futures/{settle}/orders_timerange", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetOrdersWithTimeRange", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a batch of futures orders - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;BatchFuturesOrder&gt;</returns>
        public List<BatchFuturesOrder> CreateBatchFuturesOrder (string settle, List<FuturesOrder> futuresOrder, string xGateExptime = default(string))
        {
             ApiResponse<List<BatchFuturesOrder>> localVarResponse = CreateBatchFuturesOrderWithHttpInfo(settle, futuresOrder, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a batch of futures orders - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;BatchFuturesOrder&gt;</returns>
        public ApiResponse<List<BatchFuturesOrder>> CreateBatchFuturesOrderWithHttpInfo (string settle, List<FuturesOrder> futuresOrder, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreateBatchFuturesOrder");

            // verify the required parameter 'futuresOrder' is set
            if (futuresOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrder' when calling FuturesApi->CreateBatchFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = futuresOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<BatchFuturesOrder>>("/futures/{settle}/batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateBatchFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a batch of futures orders - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;BatchFuturesOrder&gt;</returns>
        public async Task<List<BatchFuturesOrder>> CreateBatchFuturesOrderAsync (string settle, List<FuturesOrder> futuresOrder, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<BatchFuturesOrder>> localVarResponse = await CreateBatchFuturesOrderAsyncWithHttpInfo(settle, futuresOrder, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a batch of futures orders - Up to 10 orders per request - If any of the order&#39;s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the &#x60;succeeded&#x60; field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the &#x60;label&#x60; field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresOrder"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BatchFuturesOrder&gt;)</returns>
        public async Task<ApiResponse<List<BatchFuturesOrder>>> CreateBatchFuturesOrderAsyncWithHttpInfo (string settle, List<FuturesOrder> futuresOrder, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreateBatchFuturesOrder");

            // verify the required parameter 'futuresOrder' is set
            if (futuresOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrder' when calling FuturesApi->CreateBatchFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = futuresOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<BatchFuturesOrder>>("/futures/{settle}/batch_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateBatchFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single order - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>FuturesOrder</returns>
        public FuturesOrder GetFuturesOrder (string settle, string orderId)
        {
             ApiResponse<FuturesOrder> localVarResponse = GetFuturesOrderWithHttpInfo(settle, orderId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single order - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        public ApiResponse<FuturesOrder> GetFuturesOrderWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->GetFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a single order - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of FuturesOrder</returns>
        public async Task<FuturesOrder> GetFuturesOrderAsync (string settle, string orderId)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrder> localVarResponse = await GetFuturesOrderAsyncWithHttpInfo(settle, orderId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single order - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        public async Task<ApiResponse<FuturesOrder>> GetFuturesOrderAsyncWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->GetFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Amend an order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>FuturesOrder</returns>
        public FuturesOrder AmendFuturesOrder (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment, string xGateExptime = default(string))
        {
             ApiResponse<FuturesOrder> localVarResponse = AmendFuturesOrderWithHttpInfo(settle, orderId, futuresOrderAmendment, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Amend an order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        public ApiResponse<FuturesOrder> AmendFuturesOrderWithHttpInfo (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->AmendFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->AmendFuturesOrder");

            // verify the required parameter 'futuresOrderAmendment' is set
            if (futuresOrderAmendment == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrderAmendment' when calling FuturesApi->AmendFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = futuresOrderAmendment;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Put<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Amend an order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of FuturesOrder</returns>
        public async Task<FuturesOrder> AmendFuturesOrderAsync (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrder> localVarResponse = await AmendFuturesOrderAsyncWithHttpInfo(settle, orderId, futuresOrderAmendment, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Amend an order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="futuresOrderAmendment"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        public async Task<ApiResponse<FuturesOrder>> AmendFuturesOrderAsyncWithHttpInfo (string settle, string orderId, FuturesOrderAmendment futuresOrderAmendment, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->AmendFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->AmendFuturesOrder");

            // verify the required parameter 'futuresOrderAmendment' is set
            if (futuresOrderAmendment == null)
                throw new ApiException(400, "Missing required parameter 'futuresOrderAmendment' when calling FuturesApi->AmendFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = futuresOrderAmendment;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PutAsync<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel a single order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>FuturesOrder</returns>
        public FuturesOrder CancelFuturesOrder (string settle, string orderId, string xGateExptime = default(string))
        {
             ApiResponse<FuturesOrder> localVarResponse = CancelFuturesOrderWithHttpInfo(settle, orderId, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel a single order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of FuturesOrder</returns>
        public ApiResponse<FuturesOrder> CancelFuturesOrderWithHttpInfo (string settle, string orderId, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->CancelFuturesOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel a single order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of FuturesOrder</returns>
        public async Task<FuturesOrder> CancelFuturesOrderAsync (string settle, string orderId, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesOrder> localVarResponse = await CancelFuturesOrderAsyncWithHttpInfo(settle, orderId, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel a single order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook.  When the order is finished, it can be checked within 60 seconds after the end of the order.  After that, only order ID is accepted.</param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (FuturesOrder)</returns>
        public async Task<ApiResponse<FuturesOrder>> CancelFuturesOrderAsyncWithHttpInfo (string settle, string orderId, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelFuturesOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->CancelFuturesOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<FuturesOrder>("/futures/{settle}/orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelFuturesOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List personal trading history By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/my_trades_timerange&#x60;.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)</param>
        /// <returns>List&lt;MyFuturesTrade&gt;</returns>
        public List<MyFuturesTrade> GetMyTrades (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
             ApiResponse<List<MyFuturesTrade>> localVarResponse = GetMyTradesWithHttpInfo(settle, contract, order, limit, offset, lastId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List personal trading history By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/my_trades_timerange&#x60;.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)</param>
        /// <returns>ApiResponse of List&lt;MyFuturesTrade&gt;</returns>
        public ApiResponse<List<MyFuturesTrade>> GetMyTradesWithHttpInfo (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetMyTrades");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (order != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "order", order));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<MyFuturesTrade>>("/futures/{settle}/my_trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMyTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List personal trading history By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/my_trades_timerange&#x60;.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)</param>
        /// <returns>Task of List&lt;MyFuturesTrade&gt;</returns>
        public async Task<List<MyFuturesTrade>> GetMyTradesAsync (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<MyFuturesTrade>> localVarResponse = await GetMyTradesAsyncWithHttpInfo(settle, contract, order, limit, offset, lastId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List personal trading history By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use &#x60;GET /futures/{settle}/my_trades_timerange&#x60;.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="order">Futures order ID, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="lastId">Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using &#39;GET /futures/{settle}/my_trades_timerange&#39;. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;MyFuturesTrade&gt;)</returns>
        public async Task<ApiResponse<List<MyFuturesTrade>>> GetMyTradesAsyncWithHttpInfo (string settle, string contract = default(string), long? order = default(long?), int? limit = default(int?), int? offset = default(int?), string lastId = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetMyTrades");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (order != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "order", order));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (lastId != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "last_id", lastId));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<MyFuturesTrade>>("/futures/{settle}/my_trades", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMyTrades", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List personal trading history by time range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="role">Query role, maker or taker. (optional)</param>
        /// <returns>List&lt;MyFuturesTradeTimeRange&gt;</returns>
        public List<MyFuturesTradeTimeRange> GetMyTradesWithTimeRange (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?), string role = default(string))
        {
             ApiResponse<List<MyFuturesTradeTimeRange>> localVarResponse = GetMyTradesWithTimeRangeWithHttpInfo(settle, contract, from, to, limit, offset, role);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List personal trading history by time range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="role">Query role, maker or taker. (optional)</param>
        /// <returns>ApiResponse of List&lt;MyFuturesTradeTimeRange&gt;</returns>
        public ApiResponse<List<MyFuturesTradeTimeRange>> GetMyTradesWithTimeRangeWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?), string role = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetMyTradesWithTimeRange");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (role != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "role", role));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<MyFuturesTradeTimeRange>>("/futures/{settle}/my_trades_timerange", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMyTradesWithTimeRange", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List personal trading history by time range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="role">Query role, maker or taker. (optional)</param>
        /// <returns>Task of List&lt;MyFuturesTradeTimeRange&gt;</returns>
        public async Task<List<MyFuturesTradeTimeRange>> GetMyTradesWithTimeRangeAsync (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?), string role = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<MyFuturesTradeTimeRange>> localVarResponse = await GetMyTradesWithTimeRangeAsyncWithHttpInfo(settle, contract, from, to, limit, offset, role);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List personal trading history by time range 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="role">Query role, maker or taker. (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;MyFuturesTradeTimeRange&gt;)</returns>
        public async Task<ApiResponse<List<MyFuturesTradeTimeRange>>> GetMyTradesWithTimeRangeAsyncWithHttpInfo (string settle, string contract = default(string), long? from = default(long?), long? to = default(long?), int? limit = default(int?), int? offset = default(int?), string role = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetMyTradesWithTimeRange");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (role != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "role", role));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<MyFuturesTradeTimeRange>>("/futures/{settle}/my_trades_timerange", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetMyTradesWithTimeRange", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List position close history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="side">Query side.  long or shot (optional)</param>
        /// <param name="pnl">Query profit or loss (optional)</param>
        /// <returns>List&lt;PositionClose&gt;</returns>
        public List<PositionClose> ListPositionClose (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string side = default(string), string pnl = default(string))
        {
             ApiResponse<List<PositionClose>> localVarResponse = ListPositionCloseWithHttpInfo(settle, contract, limit, offset, from, to, side, pnl);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List position close history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="side">Query side.  long or shot (optional)</param>
        /// <param name="pnl">Query profit or loss (optional)</param>
        /// <returns>ApiResponse of List&lt;PositionClose&gt;</returns>
        public ApiResponse<List<PositionClose>> ListPositionCloseWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string side = default(string), string pnl = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPositionClose");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }
            if (pnl != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pnl", pnl));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<PositionClose>>("/futures/{settle}/position_close", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPositionClose", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List position close history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="side">Query side.  long or shot (optional)</param>
        /// <param name="pnl">Query profit or loss (optional)</param>
        /// <returns>Task of List&lt;PositionClose&gt;</returns>
        public async Task<List<PositionClose>> ListPositionCloseAsync (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string side = default(string), string pnl = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<PositionClose>> localVarResponse = await ListPositionCloseAsyncWithHttpInfo(settle, contract, limit, offset, from, to, side, pnl);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List position close history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <param name="from">Start timestamp (optional)</param>
        /// <param name="to">End timestamp (optional)</param>
        /// <param name="side">Query side.  long or shot (optional)</param>
        /// <param name="pnl">Query profit or loss (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;PositionClose&gt;)</returns>
        public async Task<ApiResponse<List<PositionClose>>> ListPositionCloseAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? offset = default(int?), long? from = default(long?), long? to = default(long?), string side = default(string), string pnl = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPositionClose");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }
            if (from != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "from", from));
            }
            if (to != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "to", to));
            }
            if (side != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "side", side));
            }
            if (pnl != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "pnl", pnl));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<PositionClose>>("/futures/{settle}/position_close", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPositionClose", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List liquidation history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>List&lt;FuturesLiquidate&gt;</returns>
        public List<FuturesLiquidate> ListLiquidates (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
             ApiResponse<List<FuturesLiquidate>> localVarResponse = ListLiquidatesWithHttpInfo(settle, contract, limit, at);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List liquidation history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesLiquidate&gt;</returns>
        public ApiResponse<List<FuturesLiquidate>> ListLiquidatesWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListLiquidates");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (at != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "at", at));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesLiquidate>>("/futures/{settle}/liquidates", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLiquidates", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List liquidation history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesLiquidate&gt;</returns>
        public async Task<List<FuturesLiquidate>> ListLiquidatesAsync (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesLiquidate>> localVarResponse = await ListLiquidatesAsyncWithHttpInfo(settle, contract, limit, at);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List liquidation history 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify a liquidation timestamp (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesLiquidate&gt;)</returns>
        public async Task<ApiResponse<List<FuturesLiquidate>>> ListLiquidatesAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListLiquidates");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (at != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "at", at));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesLiquidate>>("/futures/{settle}/liquidates", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListLiquidates", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Auto-Deleveraging History 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>List&lt;FuturesAutoDeleverage&gt;</returns>
        public List<FuturesAutoDeleverage> ListAutoDeleverages (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
             ApiResponse<List<FuturesAutoDeleverage>> localVarResponse = ListAutoDeleveragesWithHttpInfo(settle, contract, limit, at);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List Auto-Deleveraging History 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesAutoDeleverage&gt;</returns>
        public ApiResponse<List<FuturesAutoDeleverage>> ListAutoDeleveragesWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListAutoDeleverages");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (at != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "at", at));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesAutoDeleverage>>("/futures/{settle}/auto_deleverages", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAutoDeleverages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List Auto-Deleveraging History 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesAutoDeleverage&gt;</returns>
        public async Task<List<FuturesAutoDeleverage>> ListAutoDeleveragesAsync (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesAutoDeleverage>> localVarResponse = await ListAutoDeleveragesAsyncWithHttpInfo(settle, contract, limit, at);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List Auto-Deleveraging History 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="at">Specify an auto-deleveraging timestamp (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesAutoDeleverage&gt;)</returns>
        public async Task<ApiResponse<List<FuturesAutoDeleverage>>> ListAutoDeleveragesAsyncWithHttpInfo (string settle, string contract = default(string), int? limit = default(int?), int? at = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListAutoDeleverages");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (at != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "at", at));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesAutoDeleverage>>("/futures/{settle}/auto_deleverages", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListAutoDeleverages", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Countdown cancel orders When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>TriggerTime</returns>
        public TriggerTime CountdownCancelAllFutures (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask)
        {
             ApiResponse<TriggerTime> localVarResponse = CountdownCancelAllFuturesWithHttpInfo(settle, countdownCancelAllFuturesTask);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Countdown cancel orders When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>ApiResponse of TriggerTime</returns>
        public ApiResponse<TriggerTime> CountdownCancelAllFuturesWithHttpInfo (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CountdownCancelAllFutures");

            // verify the required parameter 'countdownCancelAllFuturesTask' is set
            if (countdownCancelAllFuturesTask == null)
                throw new ApiException(400, "Missing required parameter 'countdownCancelAllFuturesTask' when calling FuturesApi->CountdownCancelAllFutures");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = countdownCancelAllFuturesTask;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<TriggerTime>("/futures/{settle}/countdown_cancel_all", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CountdownCancelAllFutures", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Countdown cancel orders When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>Task of TriggerTime</returns>
        public async Task<TriggerTime> CountdownCancelAllFuturesAsync (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask)
        {
             Io.Gate.GateApi.Client.ApiResponse<TriggerTime> localVarResponse = await CountdownCancelAllFuturesAsyncWithHttpInfo(settle, countdownCancelAllFuturesTask);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Countdown cancel orders When the timeout set by the user is reached, if there is no cancel or set a new countdown, the related pending orders will be automatically cancelled.  This endpoint can be called repeatedly to set a new countdown or cancel the countdown. For example, call this endpoint at 30s intervals, each countdown&#x60;timeout&#x60; is set to 30s. If this endpoint is not called again within 30 seconds, all pending orders on the specified &#x60;market&#x60; will be automatically cancelled, if no &#x60;market&#x60; is specified, all market pending orders will be cancelled. If the &#x60;timeout&#x60; is set to 0 within 30 seconds, the countdown timer will expire and the cacnel function will be cancelled.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="countdownCancelAllFuturesTask"></param>
        /// <returns>Task of ApiResponse (TriggerTime)</returns>
        public async Task<ApiResponse<TriggerTime>> CountdownCancelAllFuturesAsyncWithHttpInfo (string settle, CountdownCancelAllFuturesTask countdownCancelAllFuturesTask)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CountdownCancelAllFutures");

            // verify the required parameter 'countdownCancelAllFuturesTask' is set
            if (countdownCancelAllFuturesTask == null)
                throw new ApiException(400, "Missing required parameter 'countdownCancelAllFuturesTask' when calling FuturesApi->CountdownCancelAllFutures");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = countdownCancelAllFuturesTask;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<TriggerTime>("/futures/{settle}/countdown_cancel_all", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CountdownCancelAllFutures", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query user trading fee rates 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Dictionary&lt;string, FuturesFee&gt;</returns>
        public Dictionary<string, FuturesFee> GetFuturesFee (string settle, string contract = default(string))
        {
             ApiResponse<Dictionary<string, FuturesFee>> localVarResponse = GetFuturesFeeWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Query user trading fee rates 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>ApiResponse of Dictionary&lt;string, FuturesFee&gt;</returns>
        public ApiResponse<Dictionary<string, FuturesFee>> GetFuturesFeeWithHttpInfo (string settle, string contract = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesFee");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<Dictionary<string, FuturesFee>>("/futures/{settle}/fee", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesFee", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Query user trading fee rates 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of Dictionary&lt;string, FuturesFee&gt;</returns>
        public async Task<Dictionary<string, FuturesFee>> GetFuturesFeeAsync (string settle, string contract = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<Dictionary<string, FuturesFee>> localVarResponse = await GetFuturesFeeAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Query user trading fee rates 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of ApiResponse (Dictionary&lt;string, FuturesFee&gt;)</returns>
        public async Task<ApiResponse<Dictionary<string, FuturesFee>>> GetFuturesFeeAsyncWithHttpInfo (string settle, string contract = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetFuturesFee");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Dictionary<string, FuturesFee>>("/futures/{settle}/fee", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetFuturesFee", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel a batch of orders with an ID list Multiple distinct order ID list can be specified。Each request can cancel a maximum of 20 records.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="requestBody"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;FutureCancelOrderResult&gt;</returns>
        public List<FutureCancelOrderResult> CancelBatchFutureOrders (string settle, List<string> requestBody, string xGateExptime = default(string))
        {
             ApiResponse<List<FutureCancelOrderResult>> localVarResponse = CancelBatchFutureOrdersWithHttpInfo(settle, requestBody, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel a batch of orders with an ID list Multiple distinct order ID list can be specified。Each request can cancel a maximum of 20 records.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="requestBody"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;FutureCancelOrderResult&gt;</returns>
        public ApiResponse<List<FutureCancelOrderResult>> CancelBatchFutureOrdersWithHttpInfo (string settle, List<string> requestBody, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelBatchFutureOrders");

            // verify the required parameter 'requestBody' is set
            if (requestBody == null)
                throw new ApiException(400, "Missing required parameter 'requestBody' when calling FuturesApi->CancelBatchFutureOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = requestBody;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<FutureCancelOrderResult>>("/futures/{settle}/batch_cancel_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelBatchFutureOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel a batch of orders with an ID list Multiple distinct order ID list can be specified。Each request can cancel a maximum of 20 records.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="requestBody"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;FutureCancelOrderResult&gt;</returns>
        public async Task<List<FutureCancelOrderResult>> CancelBatchFutureOrdersAsync (string settle, List<string> requestBody, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FutureCancelOrderResult>> localVarResponse = await CancelBatchFutureOrdersAsyncWithHttpInfo(settle, requestBody, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel a batch of orders with an ID list Multiple distinct order ID list can be specified。Each request can cancel a maximum of 20 records.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="requestBody"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FutureCancelOrderResult&gt;)</returns>
        public async Task<ApiResponse<List<FutureCancelOrderResult>>> CancelBatchFutureOrdersAsyncWithHttpInfo (string settle, List<string> requestBody, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelBatchFutureOrders");

            // verify the required parameter 'requestBody' is set
            if (requestBody == null)
                throw new ApiException(400, "Missing required parameter 'requestBody' when calling FuturesApi->CancelBatchFutureOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = requestBody;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<FutureCancelOrderResult>>("/futures/{settle}/batch_cancel_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelBatchFutureOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Batch modify orders with specified IDs You can specify multiple different order IDs. You can only modify up to 10 orders in one request.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="batchAmendOrderReq"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>List&lt;BatchFuturesOrder&gt;</returns>
        public List<BatchFuturesOrder> AmendBatchFutureOrders (string settle, List<BatchAmendOrderReq> batchAmendOrderReq, string xGateExptime = default(string))
        {
             ApiResponse<List<BatchFuturesOrder>> localVarResponse = AmendBatchFutureOrdersWithHttpInfo(settle, batchAmendOrderReq, xGateExptime);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Batch modify orders with specified IDs You can specify multiple different order IDs. You can only modify up to 10 orders in one request.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="batchAmendOrderReq"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>ApiResponse of List&lt;BatchFuturesOrder&gt;</returns>
        public ApiResponse<List<BatchFuturesOrder>> AmendBatchFutureOrdersWithHttpInfo (string settle, List<BatchAmendOrderReq> batchAmendOrderReq, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->AmendBatchFutureOrders");

            // verify the required parameter 'batchAmendOrderReq' is set
            if (batchAmendOrderReq == null)
                throw new ApiException(400, "Missing required parameter 'batchAmendOrderReq' when calling FuturesApi->AmendBatchFutureOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = batchAmendOrderReq;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<List<BatchFuturesOrder>>("/futures/{settle}/batch_amend_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendBatchFutureOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Batch modify orders with specified IDs You can specify multiple different order IDs. You can only modify up to 10 orders in one request.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="batchAmendOrderReq"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of List&lt;BatchFuturesOrder&gt;</returns>
        public async Task<List<BatchFuturesOrder>> AmendBatchFutureOrdersAsync (string settle, List<BatchAmendOrderReq> batchAmendOrderReq, string xGateExptime = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<BatchFuturesOrder>> localVarResponse = await AmendBatchFutureOrdersAsyncWithHttpInfo(settle, batchAmendOrderReq, xGateExptime);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Batch modify orders with specified IDs You can specify multiple different order IDs. You can only modify up to 10 orders in one request.
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="batchAmendOrderReq"></param>
        /// <param name="xGateExptime">Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;BatchFuturesOrder&gt;)</returns>
        public async Task<ApiResponse<List<BatchFuturesOrder>>> AmendBatchFutureOrdersAsyncWithHttpInfo (string settle, List<BatchAmendOrderReq> batchAmendOrderReq, string xGateExptime = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->AmendBatchFutureOrders");

            // verify the required parameter 'batchAmendOrderReq' is set
            if (batchAmendOrderReq == null)
                throw new ApiException(400, "Missing required parameter 'batchAmendOrderReq' when calling FuturesApi->AmendBatchFutureOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (xGateExptime != null)
            {
                localVarRequestOptions.HeaderParameters.Add("x-gate-exptime", ClientUtils.ParameterToString(xGateExptime)); // header parameter
            }
            localVarRequestOptions.Data = batchAmendOrderReq;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<List<BatchFuturesOrder>>("/futures/{settle}/batch_amend_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AmendBatchFutureOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List All Price-triggered Orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public List<FuturesPriceTriggeredOrder> ListPriceTriggeredOrders (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
             ApiResponse<List<FuturesPriceTriggeredOrder>> localVarResponse = ListPriceTriggeredOrdersWithHttpInfo(settle, status, contract, limit, offset);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List All Price-triggered Orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>ApiResponse of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public ApiResponse<List<FuturesPriceTriggeredOrder>> ListPriceTriggeredOrdersWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPriceTriggeredOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling FuturesApi->ListPriceTriggeredOrders");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<FuturesPriceTriggeredOrder>>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPriceTriggeredOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List All Price-triggered Orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public async Task<List<FuturesPriceTriggeredOrder>> ListPriceTriggeredOrdersAsync (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesPriceTriggeredOrder>> localVarResponse = await ListPriceTriggeredOrdersAsyncWithHttpInfo(settle, status, contract, limit, offset);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List All Price-triggered Orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="status">Only list the orders with this status</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <param name="limit">Maximum number of records to be returned in a single list (optional, default to 100)</param>
        /// <param name="offset">List offset, starting from 0 (optional, default to 0)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPriceTriggeredOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesPriceTriggeredOrder>>> ListPriceTriggeredOrdersAsyncWithHttpInfo (string settle, string status, string contract = default(string), int? limit = default(int?), int? offset = default(int?))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->ListPriceTriggeredOrders");

            // verify the required parameter 'status' is set
            if (status == null)
                throw new ApiException(400, "Missing required parameter 'status' when calling FuturesApi->ListPriceTriggeredOrders");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "status", status));
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }
            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "offset", offset));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<FuturesPriceTriggeredOrder>>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListPriceTriggeredOrders", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>TriggerOrderResponse</returns>
        public TriggerOrderResponse CreatePriceTriggeredOrder (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder)
        {
             ApiResponse<TriggerOrderResponse> localVarResponse = CreatePriceTriggeredOrderWithHttpInfo(settle, futuresPriceTriggeredOrder);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>ApiResponse of TriggerOrderResponse</returns>
        public ApiResponse<TriggerOrderResponse> CreatePriceTriggeredOrderWithHttpInfo (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreatePriceTriggeredOrder");

            // verify the required parameter 'futuresPriceTriggeredOrder' is set
            if (futuresPriceTriggeredOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresPriceTriggeredOrder' when calling FuturesApi->CreatePriceTriggeredOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = futuresPriceTriggeredOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Post<TriggerOrderResponse>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreatePriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>Task of TriggerOrderResponse</returns>
        public async Task<TriggerOrderResponse> CreatePriceTriggeredOrderAsync (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder)
        {
             Io.Gate.GateApi.Client.ApiResponse<TriggerOrderResponse> localVarResponse = await CreatePriceTriggeredOrderAsyncWithHttpInfo(settle, futuresPriceTriggeredOrder);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="futuresPriceTriggeredOrder"></param>
        /// <returns>Task of ApiResponse (TriggerOrderResponse)</returns>
        public async Task<ApiResponse<TriggerOrderResponse>> CreatePriceTriggeredOrderAsyncWithHttpInfo (string settle, FuturesPriceTriggeredOrder futuresPriceTriggeredOrder)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CreatePriceTriggeredOrder");

            // verify the required parameter 'futuresPriceTriggeredOrder' is set
            if (futuresPriceTriggeredOrder == null)
                throw new ApiException(400, "Missing required parameter 'futuresPriceTriggeredOrder' when calling FuturesApi->CreatePriceTriggeredOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
                "application/json"
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.Data = futuresPriceTriggeredOrder;

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.PostAsync<TriggerOrderResponse>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreatePriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel All Price-triggered Orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public List<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderList (string settle, string contract = default(string))
        {
             ApiResponse<List<FuturesPriceTriggeredOrder>> localVarResponse = CancelPriceTriggeredOrderListWithHttpInfo(settle, contract);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Cancel All Price-triggered Orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>ApiResponse of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public ApiResponse<List<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderListWithHttpInfo (string settle, string contract = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelPriceTriggeredOrderList");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<List<FuturesPriceTriggeredOrder>>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelPriceTriggeredOrderList", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Cancel All Price-triggered Orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of List&lt;FuturesPriceTriggeredOrder&gt;</returns>
        public async Task<List<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderListAsync (string settle, string contract = default(string))
        {
             Io.Gate.GateApi.Client.ApiResponse<List<FuturesPriceTriggeredOrder>> localVarResponse = await CancelPriceTriggeredOrderListAsyncWithHttpInfo(settle, contract);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Cancel All Price-triggered Orders 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="contract">Futures contract, return related data only if specified (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;FuturesPriceTriggeredOrder&gt;)</returns>
        public async Task<ApiResponse<List<FuturesPriceTriggeredOrder>>> CancelPriceTriggeredOrderListAsyncWithHttpInfo (string settle, string contract = default(string))
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelPriceTriggeredOrderList");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            if (contract != null)
            {
                localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "contract", contract));
            }

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<List<FuturesPriceTriggeredOrder>>("/futures/{settle}/price_orders", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelPriceTriggeredOrderList", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>FuturesPriceTriggeredOrder</returns>
        public FuturesPriceTriggeredOrder GetPriceTriggeredOrder (string settle, string orderId)
        {
             ApiResponse<FuturesPriceTriggeredOrder> localVarResponse = GetPriceTriggeredOrderWithHttpInfo(settle, orderId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>ApiResponse of FuturesPriceTriggeredOrder</returns>
        public ApiResponse<FuturesPriceTriggeredOrder> GetPriceTriggeredOrderWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetPriceTriggeredOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->GetPriceTriggeredOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Get<FuturesPriceTriggeredOrder>("/futures/{settle}/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of FuturesPriceTriggeredOrder</returns>
        public async Task<FuturesPriceTriggeredOrder> GetPriceTriggeredOrderAsync (string settle, string orderId)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesPriceTriggeredOrder> localVarResponse = await GetPriceTriggeredOrderAsyncWithHttpInfo(settle, orderId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of ApiResponse (FuturesPriceTriggeredOrder)</returns>
        public async Task<ApiResponse<FuturesPriceTriggeredOrder>> GetPriceTriggeredOrderAsyncWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->GetPriceTriggeredOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->GetPriceTriggeredOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<FuturesPriceTriggeredOrder>("/futures/{settle}/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// cancel a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>FuturesPriceTriggeredOrder</returns>
        public FuturesPriceTriggeredOrder CancelPriceTriggeredOrder (string settle, string orderId)
        {
             ApiResponse<FuturesPriceTriggeredOrder> localVarResponse = CancelPriceTriggeredOrderWithHttpInfo(settle, orderId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// cancel a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>ApiResponse of FuturesPriceTriggeredOrder</returns>
        public ApiResponse<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelPriceTriggeredOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->CancelPriceTriggeredOrder");

            RequestOptions localVarRequestOptions = new RequestOptions();

            string[] _contentTypes = {
            };

            // to determine the Accept header
            string[] _accepts = {
                "application/json"
            };

            var localVarContentType = ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request
            var localVarResponse = this.Client.Delete<FuturesPriceTriggeredOrder>("/futures/{settle}/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// cancel a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of FuturesPriceTriggeredOrder</returns>
        public async Task<FuturesPriceTriggeredOrder> CancelPriceTriggeredOrderAsync (string settle, string orderId)
        {
             Io.Gate.GateApi.Client.ApiResponse<FuturesPriceTriggeredOrder> localVarResponse = await CancelPriceTriggeredOrderAsyncWithHttpInfo(settle, orderId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// cancel a price-triggered order 
        /// </summary>
        /// <exception cref="Io.Gate.GateApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="settle">Settle currency</param>
        /// <param name="orderId">Retrieve the data of the order with the specified ID</param>
        /// <returns>Task of ApiResponse (FuturesPriceTriggeredOrder)</returns>
        public async Task<ApiResponse<FuturesPriceTriggeredOrder>> CancelPriceTriggeredOrderAsyncWithHttpInfo (string settle, string orderId)
        {
            // verify the required parameter 'settle' is set
            if (settle == null)
                throw new ApiException(400, "Missing required parameter 'settle' when calling FuturesApi->CancelPriceTriggeredOrder");

            // verify the required parameter 'orderId' is set
            if (orderId == null)
                throw new ApiException(400, "Missing required parameter 'orderId' when calling FuturesApi->CancelPriceTriggeredOrder");


            RequestOptions localVarRequestOptions = new RequestOptions();

            String[] _contentTypes = new String[] {
            };

            // to determine the Accept header
            String[] _accepts = new String[] {
                "application/json"
            };

            foreach (var _contentType in _contentTypes)
                localVarRequestOptions.HeaderParameters.Add("Content-Type", _contentType);

            foreach (var _accept in _accepts)
                localVarRequestOptions.HeaderParameters.Add("Accept", _accept);

            localVarRequestOptions.PathParameters.Add("settle", ClientUtils.ParameterToString(settle)); // path parameter
            localVarRequestOptions.PathParameters.Add("order_id", ClientUtils.ParameterToString(orderId)); // path parameter

            // authentication (apiv4) required
            localVarRequestOptions.RequireApiV4Auth = true;

            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.DeleteAsync<FuturesPriceTriggeredOrder>("/futures/{settle}/price_orders/{order_id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CancelPriceTriggeredOrder", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
